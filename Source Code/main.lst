CCS PCH C Compiler, Version 5.015, 5967               23-ago-18 22:19

               Filename:   D:\Projetos\Imposto\Source Code\main.lst

               ROM used:   1598 bytes (5%)
                           Largest free fragment is 27070
               RAM used:   36 (2%) at main() level
                           64 (3%) worst case
               Stack used: 12 locations (5 in main + 7 for interrupts)
               Stack size: 31

*
1000:  GOTO   15A8
*
1008:  MOVWF  04
100A:  MOVFF  FD8,05
100E:  MOVFF  FE0,06
1012:  MOVLB  0
1014:  MOVFF  FE9,0C
1018:  MOVFF  FEA,07
101C:  MOVFF  FE1,08
1020:  MOVFF  FE2,09
1024:  MOVFF  FD9,0A
1028:  MOVFF  FDA,0B
102C:  MOVFF  FF3,12
1030:  MOVFF  FF4,13
1034:  MOVFF  FFA,14
1038:  MOVFF  00,0E
103C:  MOVFF  01,0F
1040:  MOVFF  02,10
1044:  MOVFF  03,11
1048:  BTFSS  FF2.5
104A:  GOTO   1054
104E:  BTFSC  FF2.2
1050:  GOTO   1320
1054:  MOVFF  0E,00
1058:  MOVFF  0F,01
105C:  MOVFF  10,02
1060:  MOVFF  11,03
1064:  MOVFF  0C,FE9
1068:  MOVFF  07,FEA
106C:  BSF    07.7
106E:  MOVFF  08,FE1
1072:  MOVFF  09,FE2
1076:  MOVFF  0A,FD9
107A:  MOVFF  0B,FDA
107E:  MOVFF  12,FF3
1082:  MOVFF  13,FF4
1086:  MOVFF  14,FFA
108A:  MOVF   04,W
108C:  MOVFF  06,FE0
1090:  MOVFF  05,FD8
1094:  RETFIE 0
.................... #include <main.h> 
.................... #include "18F4550.h" 
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4550 
1096:  MOVFF  FF2,0D
109A:  BCF    FF2.7
109C:  CLRF   FF7
109E:  ADDLW  B0
10A0:  MOVWF  FF6
10A2:  MOVLW  10
10A4:  ADDWFC FF7,F
10A6:  TBLRD*+
10A8:  MOVF   FF5,W
10AA:  BTFSC  0D.7
10AC:  BSF    FF2.7
10AE:  RETURN 0
10B0:  DATA 28,0C
10B2:  DATA 01,06
10B4:  DATA 20,20
10B6:  DATA 20,20
10B8:  DATA 20,20
10BA:  DATA 20,20
10BC:  DATA 20,20
10BE:  DATA 20,20
10C0:  DATA 20,20
10C2:  DATA 20,20
10C4:  DATA 00,00
*
11E4:  TBLRD*+
11E6:  MOVF   FF5,F
11E8:  BZ    1202
11EA:  MOVFF  FF6,2E
11EE:  MOVFF  FF7,2F
11F2:  MOVFF  FF5,37
11F6:  RCALL  119E
11F8:  MOVFF  2E,FF6
11FC:  MOVFF  2F,FF7
1200:  BRA    11E4
1202:  RETURN 0
*
122E:  MOVFF  FEA,36
1232:  MOVFF  FE9,35
1236:  BTFSS  2F.7
1238:  BRA    124A
123A:  BSF    35.7
123C:  BTFSS  35.4
123E:  INCF   35,F
1240:  COMF   2E,F
1242:  COMF   2F,F
1244:  INCF   2E,F
1246:  BTFSC  FD8.2
1248:  INCF   2F,F
124A:  SWAPF  2F,W
124C:  IORLW  F0
124E:  MOVWF  31
1250:  ADDWF  31,F
1252:  ADDLW  E2
1254:  MOVWF  32
1256:  ADDLW  32
1258:  MOVWF  34
125A:  MOVF   2F,W
125C:  ANDLW  0F
125E:  ADDWF  32,F
1260:  ADDWF  32,F
1262:  ADDWF  34,F
1264:  ADDLW  E9
1266:  MOVWF  33
1268:  ADDWF  33,F
126A:  ADDWF  33,F
126C:  SWAPF  2E,W
126E:  ANDLW  0F
1270:  ADDWF  33,F
1272:  ADDWF  34,F
1274:  RLCF   33,F
1276:  RLCF   34,F
1278:  COMF   34,F
127A:  RLCF   34,F
127C:  MOVF   2E,W
127E:  ANDLW  0F
1280:  ADDWF  34,F
1282:  RLCF   31,F
1284:  MOVLW  07
1286:  MOVWF  30
1288:  MOVLW  0A
128A:  DECF   33,F
128C:  ADDWF  34,F
128E:  BNC   128A
1290:  DECF   32,F
1292:  ADDWF  33,F
1294:  BNC   1290
1296:  DECF   31,F
1298:  ADDWF  32,F
129A:  BNC   1296
129C:  DECF   30,F
129E:  ADDWF  31,F
12A0:  BNC   129C
12A2:  CLRF   FEA
12A4:  MOVLW  30
12A6:  MOVWF  FE9
12A8:  MOVLW  07
12AA:  ANDWF  35,W
12AC:  BCF    35.6
12AE:  MOVF   FED,F
12B0:  ANDWF  35,W
12B2:  BNZ   12C2
12B4:  BTFSC  35.4
12B6:  MOVF   FEE,F
12B8:  BTFSC  35.4
12BA:  BRA    12C2
12BC:  MOVLW  20
12BE:  MOVWF  00
12C0:  BRA    1302
12C2:  ADDWF  FE9,F
12C4:  MOVLW  00
12C6:  ADDWFC FEA,F
12C8:  MOVF   FE9,W
12CA:  SUBLW  34
12CC:  BNZ   12D4
12CE:  MOVF   FEA,F
12D0:  BNZ   12D4
12D2:  BSF    35.6
12D4:  MOVF   FEF,W
12D6:  MOVWF  00
12D8:  BNZ   12EA
12DA:  BTFSC  35.6
12DC:  BRA    12EA
12DE:  BTFSC  35.4
12E0:  BRA    1318
12E2:  BTFSC  35.3
12E4:  BRA    12EA
12E6:  MOVLW  20
12E8:  BRA    1300
12EA:  BTFSS  35.7
12EC:  BRA    12FA
12EE:  MOVLW  2D
12F0:  MOVWF  00
12F2:  MOVF   FED,W
12F4:  BCF    35.6
12F6:  BCF    35.7
12F8:  BRA    1302
12FA:  BSF    35.3
12FC:  BCF    35.4
12FE:  MOVLW  30
1300:  ADDWF  00,F
1302:  MOVFF  FEA,2F
1306:  MOVFF  FE9,2E
130A:  MOVFF  00,37
130E:  RCALL  119E
1310:  MOVFF  2F,FEA
1314:  MOVFF  2E,FE9
1318:  MOVF   FEE,W
131A:  BTFSS  35.6
131C:  BRA    12C8
131E:  RETURN 0
*
141E:  DATA 31,3A
1420:  DATA 20,00
1422:  DATA 20,32
1424:  DATA 3A,20
1426:  DATA 00,00
1428:  DATA 33,3A
142A:  DATA 20,00
142C:  DATA 20,34
142E:  DATA 3A,20
1430:  DATA 00,00
1432:  DATA 20,49
1434:  DATA 6E,69
1436:  DATA 63,69
1438:  DATA 61,6C
143A:  DATA 69,7A
143C:  DATA 61,6E
143E:  DATA 64,6F
1440:  DATA 00,00
1442:  DATA 46,72
1444:  DATA 65,6E
1446:  DATA 74,65
1448:  DATA 00,00
....................  
.................... #list 
....................  
.................... #device ADC=10 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES WDT128                   //Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOXINST                  //Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
....................  
.................... #use delay(clock=48MHz,crystal=20MHz) 
*
10C6:  MOVLW  01
10C8:  SUBWF  3E,F
10CA:  BNC   10E4
10CC:  CLRF   FEA
10CE:  MOVLW  3E
10D0:  MOVWF  FE9
10D2:  MOVF   FEF,W
10D4:  BZ    10E4
10D6:  MOVLW  02
10D8:  MOVWF  00
10DA:  DECFSZ 00,F
10DC:  BRA    10DA
10DE:  BRA    10E0
10E0:  DECFSZ FEF,F
10E2:  BRA    10D6
10E4:  RETURN 0
*
1176:  CLRF   FEA
1178:  MOVLW  38
117A:  MOVWF  FE9
117C:  MOVF   FEF,W
117E:  BZ    119C
1180:  MOVLW  0F
1182:  MOVWF  01
1184:  CLRF   00
1186:  DECFSZ 00,F
1188:  BRA    1186
118A:  DECFSZ 01,F
118C:  BRA    1184
118E:  MOVLW  8F
1190:  MOVWF  00
1192:  DECFSZ 00,F
1194:  BRA    1192
1196:  NOP   
1198:  DECFSZ FEF,F
119A:  BRA    1180
119C:  RETURN 0
....................  
.................... // #build(reset=0x1000, interrupt=0x1008) 
.................... // #org 0x000, 0xfff { } 
....................  
.................... #include <Motor1.c> 
.................... #build(reset=0x1000, interrupt=0x1008) 
.................... #org 0x000, 0xfff { } 
....................  
.................... #define  m1p1   pin_e2 
.................... #define  m1p2   pin_c0 
.................... #define  m2p1   pin_d0 
.................... #define  m2p2   pin_d1 
....................  
.................... void tras(){ 
....................       output_bit(m1p1,0); 
....................       output_bit(m1p2,1); 
....................       output_bit(m2p1,1); 
....................       output_bit(m2p2,0);  
.................... } 
....................  
.................... void frente(){ 
....................       output_bit(m1p1,1); 
*
1594:  BSF    F8D.2
1596:  BCF    F96.2
....................       output_bit(m1p2,0); 
1598:  BCF    F8B.0
159A:  BCF    F94.0
....................       output_bit(m2p1,0); 
159C:  BCF    F8C.0
159E:  BCF    F95.0
....................       output_bit(m2p2,1);  
15A0:  BSF    F8C.1
15A2:  BCF    F95.1
15A4:  GOTO   1636 (RETURN)
.................... } 
....................  
.................... void gira_esquerda(){ 
....................       output_bit(m1p1,1); 
....................       output_bit(m1p2,0); 
....................       output_bit(m2p1,1); 
....................       output_bit(m2p2,0);    
.................... } 
....................  
.................... void gira_direita(){ 
....................       output_bit(m1p1,0); 
....................       output_bit(m1p2,1); 
....................       output_bit(m2p1,0); 
....................       output_bit(m2p2,1);    
.................... } 
....................  
.................... void esquerda_tras(){ 
....................       output_bit(m1p1,0); 
....................       output_bit(m1p2,1); 
....................       output_bit(m2p1,0); 
....................       output_bit(m2p2,0);  
.................... } 
....................  
.................... void direita_tras(){ 
....................       output_bit(m1p1,0); 
....................       output_bit(m1p2,0); 
....................       output_bit(m2p1,1); 
....................       output_bit(m2p2,0);  
.................... } 
....................  
.................... void direita_frente(){ 
....................       output_bit(m1p1,0); 
....................       output_bit(m1p2,0); 
....................       output_bit(m2p1,0); 
....................       output_bit(m2p2,1);  
.................... } 
....................  
.................... void esquerda_frente(){ 
....................       output_bit(m1p1,1); 
....................       output_bit(m1p2,0); 
....................       output_bit(m2p1,0); 
....................       output_bit(m2p2,0);  
.................... } 
....................  
.................... void para(){ 
....................       output_bit(m1p1,0); 
....................       output_bit(m1p2,0); 
....................       output_bit(m2p1,0); 
....................       output_bit(m2p2,0); 
.................... } 
....................  
.................... void motor_ini(){ 
....................    setup_timer_2(T2_DIV_BY_16,255,1);      //341 us overflow, 341 us interrupt 
*
14EC:  MOVLW  00
14EE:  IORLW  06
14F0:  MOVWF  FCA
14F2:  MOVLW  FF
14F4:  MOVWF  FCB
....................  
....................    setup_ccp1(CCP_PWM|CCP_SHUTDOWN_AC_L|CCP_SHUTDOWN_BD_L); 
14F6:  BCF    F94.2
14F8:  BCF    F8B.2
14FA:  MOVLW  0C
14FC:  MOVWF  FBD
14FE:  CLRF   FB7
1500:  CLRF   FB6
....................    setup_ccp2(CCP_PWM); 
1502:  BCF    F94.1
1504:  BCF    F8B.1
1506:  MOVWF  FBA
1508:  GOTO   1586 (RETURN)
.................... } 
....................  
.................... void set_pwm(int16 vel){ 
....................    set_pwm1_duty((int16)vel); 
150C:  MOVFF  24,02
1510:  MOVFF  23,01
1514:  RRCF   02,F
1516:  RRCF   01,F
1518:  RRCF   02,F
151A:  RRCF   01,F
151C:  RRCF   02,F
151E:  MOVFF  01,FBE
1522:  RRCF   02,F
1524:  RRCF   02,W
1526:  ANDLW  30
1528:  MOVWF  00
152A:  MOVF   FBD,W
152C:  ANDLW  CF
152E:  IORWF  00,W
1530:  MOVWF  FBD
....................    set_pwm2_duty((int16)vel);     //-50); 
1532:  MOVFF  24,02
1536:  MOVFF  23,01
153A:  RRCF   02,F
153C:  RRCF   01,F
153E:  RRCF   02,F
1540:  RRCF   01,F
1542:  RRCF   02,F
1544:  MOVFF  01,FBB
1548:  RRCF   02,F
154A:  RRCF   02,W
154C:  ANDLW  30
154E:  MOVWF  00
1550:  MOVF   FBA,W
1552:  ANDLW  CF
1554:  IORWF  00,W
1556:  MOVWF  FBA
1558:  GOTO   1590 (RETURN)
.................... } 
....................  
.................... void SetLeft(int16 vel) 
.................... { 
....................      set_pwm1_duty((int16)vel); 
.................... } 
.................... void SetRight(int16 vel) 
.................... { 
....................        set_pwm2_duty((int16)vel); 
.................... } 
....................  
.................... #include <LCD_KIT.c> 
.................... /************************************************************************/ 
.................... /*  MOD_LCD.C - Biblioteca de manipula��o de m�dulo LCD                 */ 
.................... /*                                                                      */ 
.................... /*  Autor: F�bio Pereira                                                */ 
.................... /*                                                                      */ 
.................... /************************************************************************/ 
.................... /* 
.................... lcd_cursor_on()                        fun��es LCD 
.................... lcd_cursor_pisca() 
.................... lcd_cursor_off() 
.................... lcd_corre_esquerda() 
.................... lcd_corre_direita() 
.................... lcd_envia_nibble( byte dado ) 
.................... lcd_le_byte() 
.................... lcd_ini() 
.................... lcd_pos_xy( byte x, byte y) 
.................... lcd_escreve( char c)                  \f  Clear display                            //// 
....................                                             \n  Go to start of second line               //// 
....................                                   \b  Move back one position                   //// 
....................  
.................... lcd_le( byte x, byte y) 
.................... lcd_apaga() 
.................... { 
....................  
.................... */ 
.................... // As defini��es a seguir s�o utilizadas para acesso aos pinos do display 
.................... // caso o pino RW n�o seja utilizado, comente a defini��o lcd_rw 
.................... #ifndef lcd_enable 
....................    #define lcd_rs         pin_d2      // pino rs do LCD 
....................    #define lcd_enable     pin_d3      // pino enable do LCD 
....................    #define lcd_d4         pin_d4      // pino de dados d4 do LCD 
....................    #define lcd_d5         pin_d5      // pino de dados d5 do LCD 
....................    #define lcd_d6         pin_d6      // pino de dados d6 do LCD 
....................    #define lcd_d7         pin_d7   // pino de dados d7 do LCD 
.................... #endif 
....................  
.................... #define lcd_type 2           // 0=5x7, 1=5x10, 2=2 linhas 
.................... #define lcd_seg_lin 0x40    // Endere�o da segunda linha na RAM do LCD 
....................  
.................... // a constante abaixo define a seq��ncia de inicializa��o do m�dulo LCD 
.................... byte CONST INI_LCD[4] = {0x20 | (lcd_type << 2), 0xc, 1, 6}; 
....................  
.................... /*   O 0x20 eh p configurar o tipo do display e talz. 
....................    O Segundo numero configura o modo do cursor, sendo: 
....................                -> 0xf Cursor piscante 
....................                -> 0xe Cursor comum 
....................                -> 0xc Sem cursor 
....................    O terceiro (1) limpa o display 
....................    O Quarto volta com o cursor. 
.................... */ 
....................  
.................... byte lcd_le_byte() 
.................... // l� um byte do LCD (somente com pino RW) 
.................... { 
....................    byte dado; 
....................    // configura os pinos de dados como entradas 
....................    input(lcd_d4); 
....................    input(lcd_d5); 
....................    input(lcd_d6); 
....................    input(lcd_d7); 
....................    // se o pino rw for utilizado, coloca em 1 
....................    #ifdef lcd_rw 
....................       output_high(lcd_rw); 
....................    #endif 
....................    output_high(lcd_enable); // habilita display 
....................    dado = 0;   // zera a vari�vel de leitura 
....................    // l� os quatro bits mais significativos 
....................    if (input(lcd_d7)) bit_set(dado,7); 
....................    if (input(lcd_d6)) bit_set(dado,6); 
....................    if (input(lcd_d5)) bit_set(dado,5); 
....................    if (input(lcd_d4)) bit_set(dado,4); 
....................    // d� um pulso na linha enable 
....................    output_low(lcd_enable); 
....................    output_high(lcd_enable); 
....................    // l� os quatro bits menos significativos 
....................    if (input(lcd_d7)) bit_set(dado,3); 
....................    if (input(lcd_d6)) bit_set(dado,2); 
....................    if (input(lcd_d5)) bit_set(dado,1); 
....................    if (input(lcd_d4)) bit_set(dado,0); 
....................    output_low(lcd_enable);   // desabilita o display 
....................    return dado;   // retorna o byte lido 
.................... } 
....................  
.................... void lcd_envia_nibble( byte dado ) 
.................... // envia um dado de quatro bits para o display 
.................... { 
....................    // coloca os quatro bits nas saidas 
....................    output_bit(lcd_d4,bit_test(dado,0)); 
*
10E6:  BTFSC  3F.0
10E8:  BRA    10EE
10EA:  BCF    F8C.4
10EC:  BRA    10F0
10EE:  BSF    F8C.4
10F0:  BCF    F95.4
....................    output_bit(lcd_d5,bit_test(dado,1)); 
10F2:  BTFSC  3F.1
10F4:  BRA    10FA
10F6:  BCF    F8C.5
10F8:  BRA    10FC
10FA:  BSF    F8C.5
10FC:  BCF    F95.5
....................    output_bit(lcd_d6,bit_test(dado,2)); 
10FE:  BTFSC  3F.2
1100:  BRA    1106
1102:  BCF    F8C.6
1104:  BRA    1108
1106:  BSF    F8C.6
1108:  BCF    F95.6
....................    output_bit(lcd_d7,bit_test(dado,3)); 
110A:  BTFSC  3F.3
110C:  BRA    1112
110E:  BCF    F8C.7
1110:  BRA    1114
1112:  BSF    F8C.7
1114:  BCF    F95.7
....................    // d� um pulso na linha enable 
....................    output_high(lcd_enable); 
1116:  BCF    F95.3
1118:  BSF    F8C.3
....................    output_low(lcd_enable); 
111A:  BCF    F95.3
111C:  BCF    F8C.3
111E:  RETURN 0
.................... } 
....................  
....................  
.................... void lcd_envia_byte( boolean endereco, byte dado ) 
.................... { 
....................    // coloca a linha rs em 0 
....................    output_low(lcd_rs); 
1120:  BCF    F95.2
1122:  BCF    F8C.2
....................    // aguarda o display ficar desocupado 
....................    //while ( bit_test(lcd_le_byte(),7) ) ; 
....................    // configura a linha rs dependendo do modo selecionado 
....................    output_bit(lcd_rs,endereco); 
1124:  MOVF   3C,F
1126:  BNZ   112C
1128:  BCF    F8C.2
112A:  BRA    112E
112C:  BSF    F8C.2
112E:  BCF    F95.2
....................    delay_us(100);   // aguarda 100 us 
1130:  MOVLW  64
1132:  MOVWF  3E
1134:  RCALL  10C6
....................    // caso a linha rw esteja definida, coloca em 0 
....................    #ifdef lcd_rw 
....................       output_low(lcd_rw); 
....................    #endif 
....................    // desativa linha enable 
....................    output_low(lcd_enable); 
1136:  BCF    F95.3
1138:  BCF    F8C.3
....................    // envia a primeira parte do byte 
....................    lcd_envia_nibble(dado >> 4); 
113A:  SWAPF  3D,W
113C:  MOVWF  3E
113E:  MOVLW  0F
1140:  ANDWF  3E,F
1142:  MOVFF  3E,3F
1146:  RCALL  10E6
....................    // envia a segunda parte do byte 
....................    lcd_envia_nibble(dado & 0x0f); 
1148:  MOVF   3D,W
114A:  ANDLW  0F
114C:  MOVWF  3E
114E:  MOVWF  3F
1150:  RCALL  10E6
1152:  RETURN 0
.................... } 
....................  
....................  
.................... void lcd_ini() 
.................... // rotina de inicializa��o do display 
.................... { 
....................    byte conta; 
....................    output_low(lcd_d4); 
*
144A:  BCF    F95.4
144C:  BCF    F8C.4
....................    output_low(lcd_d5); 
144E:  BCF    F95.5
1450:  BCF    F8C.5
....................    output_low(lcd_d6); 
1452:  BCF    F95.6
1454:  BCF    F8C.6
....................    output_low(lcd_d7); 
1456:  BCF    F95.7
1458:  BCF    F8C.7
....................    output_low(lcd_rs); 
145A:  BCF    F95.2
145C:  BCF    F8C.2
....................    #ifdef lcd_rw 
....................       output_high(lcd_rw); 
....................    #endif 
....................    output_low(lcd_enable); 
145E:  BCF    F95.3
1460:  BCF    F8C.3
1462:  CLRF   16
1464:  BTFSC  FF2.7
1466:  BSF    16.7
1468:  BCF    FF2.7
....................    delay_ms(15); 
146A:  MOVLW  0F
146C:  MOVWF  38
146E:  RCALL  1176
1470:  BTFSC  16.7
1472:  BSF    FF2.7
....................    // envia uma seq��ncia de 3 vezes 0x03 
....................    // e depois 0x02 para configurar o m�dulo 
....................    // para modo de 4 bits 
....................    for(conta=1;conta<=3;++conta) 
1474:  MOVLW  01
1476:  MOVWF  23
1478:  MOVF   23,W
147A:  SUBLW  03
147C:  BNC   14A6
147E:  CLRF   16
1480:  BTFSC  FF2.7
1482:  BSF    16.7
1484:  BCF    FF2.7
....................    { 
....................       lcd_envia_nibble(3); 
1486:  MOVLW  03
1488:  MOVWF  3F
148A:  RCALL  10E6
148C:  BTFSC  16.7
148E:  BSF    FF2.7
1490:  CLRF   16
1492:  BTFSC  FF2.7
1494:  BSF    16.7
1496:  BCF    FF2.7
....................       delay_ms(5); 
1498:  MOVLW  05
149A:  MOVWF  38
149C:  RCALL  1176
149E:  BTFSC  16.7
14A0:  BSF    FF2.7
14A2:  INCF   23,F
14A4:  BRA    1478
14A6:  CLRF   16
14A8:  BTFSC  FF2.7
14AA:  BSF    16.7
14AC:  BCF    FF2.7
....................    } 
....................    lcd_envia_nibble(2); 
14AE:  MOVLW  02
14B0:  MOVWF  3F
14B2:  RCALL  10E6
14B4:  BTFSC  16.7
14B6:  BSF    FF2.7
....................    // envia string de inicializa��o do display 
....................    for(conta=0;conta<=3;++conta) lcd_envia_byte(0,INI_LCD[conta]); 
14B8:  CLRF   23
14BA:  MOVF   23,W
14BC:  SUBLW  03
14BE:  BNC   14E8
14C0:  CLRF   03
14C2:  MOVF   23,W
14C4:  MOVFF  FF2,24
14C8:  BCF    FF2.7
14CA:  RCALL  1096
14CC:  BTFSC  24.7
14CE:  BSF    FF2.7
14D0:  MOVWF  24
14D2:  CLRF   16
14D4:  BTFSC  FF2.7
14D6:  BSF    16.7
14D8:  BCF    FF2.7
14DA:  CLRF   3C
14DC:  MOVWF  3D
14DE:  RCALL  1120
14E0:  BTFSC  16.7
14E2:  BSF    FF2.7
14E4:  INCF   23,F
14E6:  BRA    14BA
14E8:  GOTO   1584 (RETURN)
.................... } 
....................  
.................... void lcd_pos_xy( byte x, byte y) 
.................... { 
....................    byte endereco; 
....................    if(y!=1) 
*
1154:  DECFSZ 39,W
1156:  BRA    115A
1158:  BRA    1160
....................       endereco = lcd_seg_lin; 
115A:  MOVLW  40
115C:  MOVWF  3A
115E:  BRA    1162
....................    else 
....................       endereco = 0; 
1160:  CLRF   3A
....................    endereco += x-1; 
1162:  MOVLW  01
1164:  SUBWF  38,W
1166:  ADDWF  3A,F
....................    lcd_envia_byte(0,0x80|endereco); 
1168:  MOVF   3A,W
116A:  IORLW  80
116C:  MOVWF  3B
116E:  CLRF   3C
1170:  MOVWF  3D
1172:  RCALL  1120
1174:  RETURN 0
.................... } 
....................  
.................... void lcd_escreve( char c) 
.................... // envia caractere para o display 
.................... { 
....................    switch (c) 
*
119E:  MOVF   37,W
11A0:  XORLW  0C
11A2:  BZ    11B2
11A4:  XORLW  06
11A6:  BZ    11C2
11A8:  XORLW  07
11AA:  BZ    11C2
11AC:  XORLW  05
11AE:  BZ    11CE
11B0:  BRA    11D8
....................    { 
....................      case '\f'    :   lcd_envia_byte(0,1); 
11B2:  CLRF   3C
11B4:  MOVLW  01
11B6:  MOVWF  3D
11B8:  RCALL  1120
....................               delay_ms(2); 
11BA:  MOVLW  02
11BC:  MOVWF  38
11BE:  RCALL  1176
....................             break; 
11C0:  BRA    11E2
....................      case '\n'   : 
....................      case '\r'    :   lcd_pos_xy(1,2); 
11C2:  MOVLW  01
11C4:  MOVWF  38
11C6:  MOVLW  02
11C8:  MOVWF  39
11CA:  RCALL  1154
....................               break; 
11CC:  BRA    11E2
....................      case '\b'    :   lcd_envia_byte(0,0x10); 
11CE:  CLRF   3C
11D0:  MOVLW  10
11D2:  MOVWF  3D
11D4:  RCALL  1120
....................               break; 
11D6:  BRA    11E2
....................      default   :   lcd_envia_byte(1,c); 
11D8:  MOVLW  01
11DA:  MOVWF  3C
11DC:  MOVFF  37,3D
11E0:  RCALL  1120
....................               break; 
....................    } 
11E2:  RETURN 0
.................... } 
....................  
.................... char lcd_le( byte x, byte y) 
.................... // le caractere do display 
.................... { 
....................    char valor; 
....................    // seleciona a posi��o do caractere 
....................    lcd_pos_xy(x,y); 
....................    // ativa rs 
....................    output_high(lcd_rs); 
....................    // l� o caractere 
....................    valor = lcd_le_byte(); 
....................    // desativa rs 
....................    output_low(lcd_rs); 
....................    // retorna o valor do caractere 
....................    return valor; 
.................... } 
....................  
.................... void lcd_apaga() 
.................... { 
....................    lcd_envia_byte(0,1); 
....................    delay_ms(2); 
.................... } 
....................  
.................... void lcd_cursor_on() 
....................     { 
.................... lcd_envia_byte(0,0x0E); 
....................     } 
....................  
.................... void lcd_cursor_pisca() 
....................     { 
.................... lcd_envia_byte(0,0x0F); 
....................     } 
....................  
.................... void lcd_cursor_off() 
....................     { 
....................  lcd_envia_byte(0,0x0C); 
....................     } 
....................  
.................... void lcd_corre_esquerda() 
....................     { 
....................  lcd_envia_byte(0,0x18); 
....................     } 
....................  
.................... void lcd_corre_direita() 
....................     { 
.................... lcd_envia_byte(0,0x1C); 
....................     } 
....................  
....................  
....................  
.................... #define button1 pin_a4 
.................... #define button2 pin_a5 
.................... #define button3 pin_e0 
.................... #define button4 pin_e1 
....................  
.................... int running; 
.................... const char blankScreen[] = "                "; 
....................  
.................... #ifdef DEBUG 
.................... int16 pwm; 
.................... #endif 
....................  
.................... int16 ad1, ad2, ad3, ad4; 
.................... int16 timerBase; 
.................... int8 adCounter; 
....................  
.................... void ClearScreen(); 
.................... void Setup(); 
....................  
.................... #int_timer0 
.................... void timerTick() 
.................... { 
....................     if (running == 1) 
*
1320:  DECFSZ 17,W
1322:  BRA    1418
....................     { 
....................         if (adCounter == 1) 
1324:  DECFSZ 22,W
1326:  BRA    1338
....................         { 
....................             ad1 = read_adc(); 
1328:  BSF    FC2.1
132A:  BTFSC  FC2.1
132C:  BRA    132A
132E:  MOVFF  FC3,18
1332:  MOVFF  FC4,19
....................         } 
1336:  BRA    1374
....................         else if (adCounter == 2) 
1338:  MOVF   22,W
133A:  SUBLW  02
133C:  BNZ   134E
....................         { 
....................             ad2 = read_adc(); 
133E:  BSF    FC2.1
1340:  BTFSC  FC2.1
1342:  BRA    1340
1344:  MOVFF  FC3,1A
1348:  MOVFF  FC4,1B
....................         } 
134C:  BRA    1374
....................         else if (adCounter == 3) 
134E:  MOVF   22,W
1350:  SUBLW  03
1352:  BNZ   1364
....................         { 
....................             ad3 = read_adc(); 
1354:  BSF    FC2.1
1356:  BTFSC  FC2.1
1358:  BRA    1356
135A:  MOVFF  FC3,1C
135E:  MOVFF  FC4,1D
....................         } 
1362:  BRA    1374
....................         else 
....................         { 
....................             adCounter = 0; 
1364:  CLRF   22
....................             ad4 = read_adc(); 
1366:  BSF    FC2.1
1368:  BTFSC  FC2.1
136A:  BRA    1368
136C:  MOVFF  FC3,1E
1370:  MOVFF  FC4,1F
....................         } 
....................  
....................         set_adc_channel(adCounter + 1); 
1374:  MOVLW  01
1376:  ADDWF  22,W
1378:  MOVWF  2E
137A:  RLCF   2E,W
137C:  MOVWF  00
137E:  RLCF   00,F
1380:  MOVLW  FC
1382:  ANDWF  00,F
1384:  MOVF   FC2,W
1386:  ANDLW  C3
1388:  IORWF  00,W
138A:  MOVWF  FC2
....................  
....................         // if (ad1 + ad2 < 400) 
....................         // { 
....................         //     if ((float)ad1 / ad1 + ad2 > 0.52f) 
....................         //     { 
....................         //         SetLeft(900); 
....................         //         //SetRight((((float)ad2 / ad1 + ad2) * 200) + 800); 
....................         //         frente(); 
....................         //     } 
....................         //     else if ((float)ad2 / ad1 + ad2 > 0.52f) 
....................         //     { 
....................         //         SetRight(900); 
....................         //         //SetLeft((((float)ad1 / ad1 + ad2) * 200) + 800); 
....................         //         frente(); 
....................         //     } 
....................         //     else 
....................         //     { 
....................         //         set_pwm(900); 
....................         //         frente(); 
....................         //     } 
....................         // } 
....................         // else 
....................         // { 
....................         //     set_pwm(0); 
....................         //     //para(); 
....................         // } 
....................  
....................         if (timerBase == 2000) 
138C:  MOVF   20,W
138E:  SUBLW  D0
1390:  BNZ   1410
1392:  MOVF   21,W
1394:  SUBLW  07
1396:  BNZ   1410
....................         { 
....................             timerBase = 0; 
1398:  CLRF   21
139A:  CLRF   20
....................             ClearScreen(); 
139C:  BRA    1204
....................             lcd_pos_xy(1, 1); 
139E:  MOVLW  01
13A0:  MOVWF  38
13A2:  MOVWF  39
13A4:  RCALL  1154
....................             printf(lcd_escreve, "1: "); 
13A6:  MOVLW  1E
13A8:  MOVWF  FF6
13AA:  MOVLW  14
13AC:  MOVWF  FF7
13AE:  RCALL  11E4
....................             printf(lcd_escreve, "%04ld", ad1); 
13B0:  MOVLW  0A
13B2:  MOVWF  FE9
13B4:  MOVFF  19,2F
13B8:  MOVFF  18,2E
13BC:  RCALL  122E
....................             printf(lcd_escreve, " 2: "); 
13BE:  MOVLW  22
13C0:  MOVWF  FF6
13C2:  MOVLW  14
13C4:  MOVWF  FF7
13C6:  RCALL  11E4
....................             printf(lcd_escreve, "%04ld", ad2); 
13C8:  MOVLW  0A
13CA:  MOVWF  FE9
13CC:  MOVFF  1B,2F
13D0:  MOVFF  1A,2E
13D4:  RCALL  122E
....................             lcd_pos_xy(1, 2); 
13D6:  MOVLW  01
13D8:  MOVWF  38
13DA:  MOVLW  02
13DC:  MOVWF  39
13DE:  RCALL  1154
....................             printf(lcd_escreve, "3: "); 
13E0:  MOVLW  28
13E2:  MOVWF  FF6
13E4:  MOVLW  14
13E6:  MOVWF  FF7
13E8:  RCALL  11E4
....................             printf(lcd_escreve, "%04ld", ad3); 
13EA:  MOVLW  0A
13EC:  MOVWF  FE9
13EE:  MOVFF  1D,2F
13F2:  MOVFF  1C,2E
13F6:  RCALL  122E
....................             printf(lcd_escreve, " 4: "); 
13F8:  MOVLW  2C
13FA:  MOVWF  FF6
13FC:  MOVLW  14
13FE:  MOVWF  FF7
1400:  RCALL  11E4
....................             printf(lcd_escreve, "%04ld", ad4); 
1402:  MOVLW  0A
1404:  MOVWF  FE9
1406:  MOVFF  1F,2F
140A:  MOVFF  1E,2E
140E:  RCALL  122E
....................         } 
....................         timerBase++; 
1410:  INCF   20,F
1412:  BTFSC  FD8.2
1414:  INCF   21,F
....................         adCounter++; 
1416:  INCF   22,F
....................         ///Seta para pegar no proximo tick 
....................     } 
1418:  BCF    FF2.2
141A:  GOTO   1054
.................... } 
....................  
.................... void main() 
*
15A8:  CLRF   FF8
15AA:  BCF    FD0.7
15AC:  BSF    07.7
15AE:  MOVF   FC1,W
15B0:  ANDLW  C0
15B2:  IORLW  0F
15B4:  MOVWF  FC1
15B6:  MOVLW  07
15B8:  MOVWF  FB4
.................... { 
....................     Setup(); 
15BA:  BRA    155C
15BC:  CLRF   16
15BE:  BTFSC  FF2.7
15C0:  BSF    16.7
15C2:  BCF    FF2.7
....................     lcd_pos_xy(1, 1); 
15C4:  MOVLW  01
15C6:  MOVWF  38
15C8:  MOVWF  39
15CA:  RCALL  1154
15CC:  BTFSC  16.7
15CE:  BSF    FF2.7
....................     printf(lcd_escreve, " Inicializando"); 
15D0:  MOVLW  32
15D2:  MOVWF  FF6
15D4:  MOVLW  14
15D6:  MOVWF  FF7
15D8:  CLRF   16
15DA:  BTFSC  FF2.7
15DC:  BSF    16.7
15DE:  BCF    FF2.7
15E0:  RCALL  11E4
15E2:  BTFSC  16.7
15E4:  BSF    FF2.7
....................     delay_ms(1000); 
15E6:  MOVLW  04
15E8:  MOVWF  23
15EA:  CLRF   16
15EC:  BTFSC  FF2.7
15EE:  BSF    16.7
15F0:  BCF    FF2.7
15F2:  MOVLW  FA
15F4:  MOVWF  38
15F6:  RCALL  1176
15F8:  BTFSC  16.7
15FA:  BSF    FF2.7
15FC:  DECFSZ 23,F
15FE:  BRA    15EA
....................     do 
....................     { 
....................         if (input(button1) == 0) 
1600:  BSF    F92.4
1602:  BTFSC  F80.4
1604:  BRA    1636
....................         { 
....................             running = 1; 
1606:  MOVLW  01
1608:  MOVWF  17
160A:  CLRF   16
160C:  BTFSC  FF2.7
160E:  BSF    16.7
1610:  BCF    FF2.7
....................             lcd_pos_xy(1,1); 
1612:  MOVLW  01
1614:  MOVWF  38
1616:  MOVWF  39
1618:  RCALL  1154
161A:  BTFSC  16.7
161C:  BSF    FF2.7
....................             printf(lcd_escreve, "Frente"); 
161E:  MOVLW  42
1620:  MOVWF  FF6
1622:  MOVLW  14
1624:  MOVWF  FF7
1626:  CLRF   16
1628:  BTFSC  FF2.7
162A:  BSF    16.7
162C:  BCF    FF2.7
162E:  RCALL  11E4
1630:  BTFSC  16.7
1632:  BSF    FF2.7
....................             frente(); 
1634:  BRA    1594
....................         } 
....................         if (input(button2) == 0) 
1636:  BSF    F92.5
1638:  BTFSC  F80.5
163A:  BRA    163E
....................         { 
....................             running = 0; 
163C:  CLRF   17
....................         } 
....................     } while (1); 
163E:  BRA    1600
.................... } 
....................  
1640:  SLEEP 
.................... void Setup() 
.................... { 
....................     running = 1; 
*
155C:  MOVLW  01
155E:  MOVWF  17
....................     adCounter = 1; 
1560:  MOVWF  22
....................  
....................     setup_adc_ports(AN0_TO_AN3); 
1562:  MOVF   FC1,W
1564:  ANDLW  C0
1566:  IORLW  0B
1568:  MOVWF  FC1
....................     setup_adc(ADC_CLOCK_DIV_4); 
156A:  MOVF   FC0,W
156C:  ANDLW  C0
156E:  IORLW  04
1570:  MOVWF  FC0
1572:  BSF    FC0.7
1574:  BSF    FC2.0
....................  
....................     setup_timer_0(RTCC_INTERNAL | RTCC_DIV_2 | RTCC_8_BIT); 
1576:  MOVLW  C0
1578:  MOVWF  FD5
....................     set_timer0(0); 
157A:  CLRF   FD7
157C:  CLRF   FD6
....................     enable_interrupts(INT_TIMER0); 
157E:  BSF    FF2.5
....................     enable_interrupts(GLOBAL); 
1580:  IORWF  FF2,F
....................  
....................     lcd_ini(); 
1582:  BRA    144A
....................     motor_ini(); 
1584:  BRA    14EC
....................     set_pwm(900); 
1586:  MOVLW  03
1588:  MOVWF  24
158A:  MOVLW  84
158C:  MOVWF  23
158E:  BRA    150C
1590:  GOTO   15BC (RETURN)
.................... } 
....................  
.................... void ClearScreen() 
.................... { 
....................     lcd_pos_xy(1, 1); 
*
1204:  MOVLW  01
1206:  MOVWF  38
1208:  MOVWF  39
120A:  RCALL  1154
....................     printf(lcd_escreve, blankScreen); 
120C:  MOVLW  B4
120E:  MOVWF  FF6
1210:  MOVLW  10
1212:  MOVWF  FF7
1214:  RCALL  11E4
....................     lcd_pos_xy(1, 2); 
1216:  MOVLW  01
1218:  MOVWF  38
121A:  MOVLW  02
121C:  MOVWF  39
121E:  RCALL  1154
....................     printf(lcd_escreve, blankScreen); 
1220:  MOVLW  B4
1222:  MOVWF  FF6
1224:  MOVLW  10
1226:  MOVWF  FF7
1228:  RCALL  11E4
122A:  GOTO   139E (RETURN)
.................... } 

Configuration Fuses:
   Word  1: CE24   PLL5 CPUDIV1 USBDIV HSPLL FCMEN IESO
   Word  2: 0E38   PUT NOBROWNOUT BORV21 VREGEN NOWDT WDT128
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
