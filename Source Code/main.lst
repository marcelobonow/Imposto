CCS PCH C Compiler, Version 5.015, 5967               27-ago-18 01:20

               Filename:   D:\Projetos\Imposto\Source Code\main.lst

               ROM used:   2476 bytes (8%)
                           Largest free fragment is 26192
               RAM used:   36 (2%) at main() level
                           72 (4%) worst case
               Stack used: 11 locations (5 in main + 6 for interrupts)
               Stack size: 31

*
1000:  GOTO   192C
*
1008:  MOVWF  04
100A:  MOVFF  FD8,05
100E:  MOVFF  FE0,06
1012:  MOVLB  0
1014:  MOVFF  FE9,0C
1018:  MOVFF  FEA,07
101C:  MOVFF  FE1,08
1020:  MOVFF  FE2,09
1024:  MOVFF  FD9,0A
1028:  MOVFF  FDA,0B
102C:  MOVFF  FF3,12
1030:  MOVFF  FF4,13
1034:  MOVFF  FFA,14
1038:  MOVFF  00,0E
103C:  MOVFF  01,0F
1040:  MOVFF  02,10
1044:  MOVFF  03,11
1048:  BTFSS  FF2.5
104A:  GOTO   1054
104E:  BTFSC  FF2.2
1050:  GOTO   1592
1054:  MOVFF  0E,00
1058:  MOVFF  0F,01
105C:  MOVFF  10,02
1060:  MOVFF  11,03
1064:  MOVFF  0C,FE9
1068:  MOVFF  07,FEA
106C:  BSF    07.7
106E:  MOVFF  08,FE1
1072:  MOVFF  09,FE2
1076:  MOVFF  0A,FD9
107A:  MOVFF  0B,FDA
107E:  MOVFF  12,FF3
1082:  MOVFF  13,FF4
1086:  MOVFF  14,FFA
108A:  MOVF   04,W
108C:  MOVFF  06,FE0
1090:  MOVFF  05,FD8
1094:  RETFIE 0
.................... //#DEFINE DEBUG 
.................... #include <main.h> 
.................... #include "18F4550.h" 
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4550 
1096:  MOVFF  FF2,0D
109A:  BCF    FF2.7
109C:  CLRF   FF7
109E:  ADDLW  B0
10A0:  MOVWF  FF6
10A2:  MOVLW  10
10A4:  ADDWFC FF7,F
10A6:  TBLRD*+
10A8:  MOVF   FF5,W
10AA:  BTFSC  0D.7
10AC:  BSF    FF2.7
10AE:  RETURN 0
10B0:  DATA 28,0C
10B2:  DATA 01,06
*
11DC:  TBLRD*+
11DE:  MOVF   FF5,F
11E0:  BZ    11FA
11E2:  MOVFF  FF6,36
11E6:  MOVFF  FF7,37
11EA:  MOVFF  FF5,3F
11EE:  RCALL  118C
11F0:  MOVFF  36,FF6
11F4:  MOVFF  37,FF7
11F8:  BRA    11DC
11FA:  RETURN 0
11FC:  MOVFF  FEA,3E
1200:  MOVFF  FE9,3D
1204:  BTFSS  37.7
1206:  BRA    1218
1208:  BSF    3D.7
120A:  BTFSS  3D.4
120C:  INCF   3D,F
120E:  COMF   36,F
1210:  COMF   37,F
1212:  INCF   36,F
1214:  BTFSC  FD8.2
1216:  INCF   37,F
1218:  SWAPF  37,W
121A:  IORLW  F0
121C:  MOVWF  39
121E:  ADDWF  39,F
1220:  ADDLW  E2
1222:  MOVWF  3A
1224:  ADDLW  32
1226:  MOVWF  3C
1228:  MOVF   37,W
122A:  ANDLW  0F
122C:  ADDWF  3A,F
122E:  ADDWF  3A,F
1230:  ADDWF  3C,F
1232:  ADDLW  E9
1234:  MOVWF  3B
1236:  ADDWF  3B,F
1238:  ADDWF  3B,F
123A:  SWAPF  36,W
123C:  ANDLW  0F
123E:  ADDWF  3B,F
1240:  ADDWF  3C,F
1242:  RLCF   3B,F
1244:  RLCF   3C,F
1246:  COMF   3C,F
1248:  RLCF   3C,F
124A:  MOVF   36,W
124C:  ANDLW  0F
124E:  ADDWF  3C,F
1250:  RLCF   39,F
1252:  MOVLW  07
1254:  MOVWF  38
1256:  MOVLW  0A
1258:  DECF   3B,F
125A:  ADDWF  3C,F
125C:  BNC   1258
125E:  DECF   3A,F
1260:  ADDWF  3B,F
1262:  BNC   125E
1264:  DECF   39,F
1266:  ADDWF  3A,F
1268:  BNC   1264
126A:  DECF   38,F
126C:  ADDWF  39,F
126E:  BNC   126A
1270:  CLRF   FEA
1272:  MOVLW  38
1274:  MOVWF  FE9
1276:  MOVLW  07
1278:  ANDWF  3D,W
127A:  BCF    3D.6
127C:  MOVF   FED,F
127E:  ANDWF  3D,W
1280:  BNZ   1290
1282:  BTFSC  3D.4
1284:  MOVF   FEE,F
1286:  BTFSC  3D.4
1288:  BRA    1290
128A:  MOVLW  20
128C:  MOVWF  00
128E:  BRA    12D0
1290:  ADDWF  FE9,F
1292:  MOVLW  00
1294:  ADDWFC FEA,F
1296:  MOVF   FE9,W
1298:  SUBLW  3C
129A:  BNZ   12A2
129C:  MOVF   FEA,F
129E:  BNZ   12A2
12A0:  BSF    3D.6
12A2:  MOVF   FEF,W
12A4:  MOVWF  00
12A6:  BNZ   12B8
12A8:  BTFSC  3D.6
12AA:  BRA    12B8
12AC:  BTFSC  3D.4
12AE:  BRA    12E6
12B0:  BTFSC  3D.3
12B2:  BRA    12B8
12B4:  MOVLW  20
12B6:  BRA    12CE
12B8:  BTFSS  3D.7
12BA:  BRA    12C8
12BC:  MOVLW  2D
12BE:  MOVWF  00
12C0:  MOVF   FED,W
12C2:  BCF    3D.6
12C4:  BCF    3D.7
12C6:  BRA    12D0
12C8:  BSF    3D.3
12CA:  BCF    3D.4
12CC:  MOVLW  30
12CE:  ADDWF  00,F
12D0:  MOVFF  FEA,37
12D4:  MOVFF  FE9,36
12D8:  MOVFF  00,3F
12DC:  RCALL  118C
12DE:  MOVFF  37,FEA
12E2:  MOVFF  36,FE9
12E6:  MOVF   FEE,W
12E8:  BTFSS  3D.6
12EA:  BRA    1296
12EC:  RETURN 0
12EE:  MOVLW  8E
12F0:  MOVWF  00
12F2:  MOVFF  3B,01
12F6:  MOVFF  3A,02
12FA:  CLRF   03
12FC:  MOVF   01,F
12FE:  BNZ   1312
1300:  MOVFF  02,01
1304:  CLRF   02
1306:  MOVLW  08
1308:  SUBWF  00,F
130A:  MOVF   01,F
130C:  BNZ   1312
130E:  CLRF   00
1310:  BRA    1322
1312:  BCF    FD8.0
1314:  BTFSC  01.7
1316:  BRA    1320
1318:  RLCF   02,F
131A:  RLCF   01,F
131C:  DECF   00,F
131E:  BRA    1312
1320:  BCF    01.7
1322:  RETURN 0
1324:  MOVF   3A,W
1326:  BTFSC  FD8.2
1328:  BRA    1474
132A:  MOVWF  46
132C:  MOVF   3E,W
132E:  BTFSC  FD8.2
1330:  BRA    1474
1332:  SUBWF  46,F
1334:  BNC   1340
1336:  MOVLW  7F
1338:  ADDWF  46,F
133A:  BTFSC  FD8.0
133C:  BRA    1474
133E:  BRA    134C
1340:  MOVLW  81
1342:  SUBWF  46,F
1344:  BTFSS  FD8.0
1346:  BRA    1474
1348:  BTFSC  FD8.2
134A:  BRA    1474
134C:  MOVFF  46,00
1350:  CLRF   01
1352:  CLRF   02
1354:  CLRF   03
1356:  CLRF   45
1358:  MOVFF  3B,44
135C:  BSF    44.7
135E:  MOVFF  3C,43
1362:  MOVFF  3D,42
1366:  MOVLW  19
1368:  MOVWF  46
136A:  MOVF   41,W
136C:  SUBWF  42,F
136E:  BC    138A
1370:  MOVLW  01
1372:  SUBWF  43,F
1374:  BC    138A
1376:  SUBWF  44,F
1378:  BC    138A
137A:  SUBWF  45,F
137C:  BC    138A
137E:  INCF   45,F
1380:  INCF   44,F
1382:  INCF   43,F
1384:  MOVF   41,W
1386:  ADDWF  42,F
1388:  BRA    13DA
138A:  MOVF   40,W
138C:  SUBWF  43,F
138E:  BC    13B4
1390:  MOVLW  01
1392:  SUBWF  44,F
1394:  BC    13B4
1396:  SUBWF  45,F
1398:  BC    13B4
139A:  INCF   45,F
139C:  INCF   44,F
139E:  MOVF   40,W
13A0:  ADDWF  43,F
13A2:  MOVF   41,W
13A4:  ADDWF  42,F
13A6:  BNC   13DA
13A8:  INCF   43,F
13AA:  BNZ   13DA
13AC:  INCF   44,F
13AE:  BNZ   13DA
13B0:  INCF   45,F
13B2:  BRA    13DA
13B4:  MOVF   3F,W
13B6:  IORLW  80
13B8:  SUBWF  44,F
13BA:  BC    13D8
13BC:  MOVLW  01
13BE:  SUBWF  45,F
13C0:  BC    13D8
13C2:  INCF   45,F
13C4:  MOVF   3F,W
13C6:  IORLW  80
13C8:  ADDWF  44,F
13CA:  MOVF   40,W
13CC:  ADDWF  43,F
13CE:  BNC   13A2
13D0:  INCF   44,F
13D2:  BNZ   13A2
13D4:  INCF   45,F
13D6:  BRA    13A2
13D8:  BSF    03.0
13DA:  DECFSZ 46,F
13DC:  BRA    13E0
13DE:  BRA    13F6
13E0:  BCF    FD8.0
13E2:  RLCF   42,F
13E4:  RLCF   43,F
13E6:  RLCF   44,F
13E8:  RLCF   45,F
13EA:  BCF    FD8.0
13EC:  RLCF   03,F
13EE:  RLCF   02,F
13F0:  RLCF   01,F
13F2:  RLCF   47,F
13F4:  BRA    136A
13F6:  BTFSS  47.0
13F8:  BRA    1406
13FA:  BCF    FD8.0
13FC:  RRCF   01,F
13FE:  RRCF   02,F
1400:  RRCF   03,F
1402:  RRCF   47,F
1404:  BRA    140A
1406:  DECF   00,F
1408:  BZ    1474
140A:  BTFSC  47.7
140C:  BRA    144A
140E:  BCF    FD8.0
1410:  RLCF   42,F
1412:  RLCF   43,F
1414:  RLCF   44,F
1416:  RLCF   45,F
1418:  MOVF   41,W
141A:  SUBWF  42,F
141C:  BC    142C
141E:  MOVLW  01
1420:  SUBWF  43,F
1422:  BC    142C
1424:  SUBWF  44,F
1426:  BC    142C
1428:  SUBWF  45,F
142A:  BNC   1460
142C:  MOVF   40,W
142E:  SUBWF  43,F
1430:  BC    143C
1432:  MOVLW  01
1434:  SUBWF  44,F
1436:  BC    143C
1438:  SUBWF  45,F
143A:  BNC   1460
143C:  MOVF   3F,W
143E:  IORLW  80
1440:  SUBWF  44,F
1442:  BC    144A
1444:  MOVLW  01
1446:  SUBWF  45,F
1448:  BNC   1460
144A:  INCF   03,F
144C:  BNZ   1460
144E:  INCF   02,F
1450:  BNZ   1460
1452:  INCF   01,F
1454:  BNZ   1460
1456:  INCF   00,F
1458:  BZ    1474
145A:  RRCF   01,F
145C:  RRCF   02,F
145E:  RRCF   03,F
1460:  MOVFF  3B,46
1464:  MOVF   3F,W
1466:  XORWF  46,F
1468:  BTFSS  46.7
146A:  BRA    1470
146C:  BSF    01.7
146E:  BRA    147C
1470:  BCF    01.7
1472:  BRA    147C
1474:  CLRF   00
1476:  CLRF   01
1478:  CLRF   02
147A:  CLRF   03
147C:  RETURN 0
147E:  MOVFF  37,3E
1482:  MOVF   3B,W
1484:  XORWF  3E,F
1486:  BTFSS  3E.7
1488:  BRA    1494
148A:  BCF    FD8.2
148C:  BCF    FD8.0
148E:  BTFSC  37.7
1490:  BSF    FD8.0
1492:  BRA    14F2
1494:  MOVFF  37,3E
1498:  MOVFF  3A,3F
149C:  MOVF   36,W
149E:  SUBWF  3F,F
14A0:  BZ    14AE
14A2:  BTFSS  3E.7
14A4:  BRA    14F2
14A6:  MOVF   FD8,W
14A8:  XORLW  01
14AA:  MOVWF  FD8
14AC:  BRA    14F2
14AE:  MOVFF  3B,3F
14B2:  MOVF   37,W
14B4:  SUBWF  3F,F
14B6:  BZ    14C4
14B8:  BTFSS  3E.7
14BA:  BRA    14F2
14BC:  MOVF   FD8,W
14BE:  XORLW  01
14C0:  MOVWF  FD8
14C2:  BRA    14F2
14C4:  MOVFF  3C,3F
14C8:  MOVF   38,W
14CA:  SUBWF  3F,F
14CC:  BZ    14DA
14CE:  BTFSS  3E.7
14D0:  BRA    14F2
14D2:  MOVF   FD8,W
14D4:  XORLW  01
14D6:  MOVWF  FD8
14D8:  BRA    14F2
14DA:  MOVFF  3D,3F
14DE:  MOVF   39,W
14E0:  SUBWF  3F,F
14E2:  BZ    14F0
14E4:  BTFSS  3E.7
14E6:  BRA    14F2
14E8:  MOVF   FD8,W
14EA:  XORLW  01
14EC:  MOVWF  FD8
14EE:  BRA    14F2
14F0:  BCF    FD8.0
14F2:  RETURN 0
*
17CE:  DATA 31,3A
17D0:  DATA 20,00
17D2:  DATA 20,32
17D4:  DATA 3A,20
17D6:  DATA 00,00
17D8:  DATA 45,73
17DA:  DATA 74,61
17DC:  DATA 20,61
17DE:  DATA 20,64
17E0:  DATA 69,72
17E2:  DATA 65,69
17E4:  DATA 74,61
17E6:  DATA 00,00
17E8:  DATA 45,73
17EA:  DATA 74,61
17EC:  DATA 20,61
17EE:  DATA 20,65
17F0:  DATA 73,71
17F2:  DATA 75,65
17F4:  DATA 72,64
17F6:  DATA 61,00
17F8:  DATA 53,65
17FA:  DATA 20,70
17FC:  DATA 65,72
17FE:  DATA 64,65
1800:  DATA 75,00
1802:  DATA 20,49
1804:  DATA 6E,69
1806:  DATA 63,69
1808:  DATA 61,6C
180A:  DATA 69,7A
180C:  DATA 61,6E
180E:  DATA 64,6F
1810:  DATA 00,00
....................  
.................... #list 
....................  
.................... #device ADC=10 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES WDT128                   //Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOXINST                  //Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
....................  
.................... #use delay(clock=48MHz,crystal=20MHz) 
*
10B4:  MOVLW  01
10B6:  SUBWF  46,F
10B8:  BNC   10D2
10BA:  CLRF   FEA
10BC:  MOVLW  46
10BE:  MOVWF  FE9
10C0:  MOVF   FEF,W
10C2:  BZ    10D2
10C4:  MOVLW  02
10C6:  MOVWF  00
10C8:  DECFSZ 00,F
10CA:  BRA    10C8
10CC:  BRA    10CE
10CE:  DECFSZ FEF,F
10D0:  BRA    10C4
10D2:  RETURN 0
*
1142:  CLRF   FEA
1144:  MOVLW  40
1146:  MOVWF  FE9
1148:  MOVF   FEF,W
114A:  BZ    1168
114C:  MOVLW  0F
114E:  MOVWF  01
1150:  CLRF   00
1152:  DECFSZ 00,F
1154:  BRA    1152
1156:  DECFSZ 01,F
1158:  BRA    1150
115A:  MOVLW  8F
115C:  MOVWF  00
115E:  DECFSZ 00,F
1160:  BRA    115E
1162:  NOP   
1164:  DECFSZ FEF,F
1166:  BRA    114C
1168:  RETURN 0
....................  
.................... // #build(reset=0x1000, interrupt=0x1008) 
.................... // #org 0x000, 0xfff { } 
....................  
.................... #include <Motor1.c> 
.................... #build(reset = 0x1000, interrupt = 0x1008) 
.................... #org 0x000, 0xfff {} 
....................  
.................... #define m1p1 pin_e2 
.................... #define m1p2 pin_c0 
.................... #define m2p1 pin_d0 
.................... #define m2p2 pin_d1 
....................  
.................... void tras() 
.................... { 
....................       output_bit(m1p1, 0); 
....................       output_bit(m1p2, 1); 
....................       output_bit(m2p1, 1); 
....................       output_bit(m2p2, 0); 
.................... } 
....................  
.................... void frente() 
.................... { 
....................       output_bit(m1p1, 1); 
*
18D4:  BSF    F8D.2
18D6:  BCF    F96.2
....................       output_bit(m1p2, 0); 
18D8:  BCF    F8B.0
18DA:  BCF    F94.0
....................       output_bit(m2p1, 0); 
18DC:  BCF    F8C.0
18DE:  BCF    F95.0
....................       output_bit(m2p2, 1); 
18E0:  BSF    F8C.1
18E2:  BCF    F95.1
18E4:  GOTO   1928 (RETURN)
.................... } 
....................  
.................... void gira_esquerda() 
.................... { 
....................       output_bit(m1p1, 1); 
....................       output_bit(m1p2, 0); 
....................       output_bit(m2p1, 1); 
....................       output_bit(m2p2, 0); 
.................... } 
....................  
.................... void gira_direita() 
.................... { 
....................       output_bit(m1p1, 0); 
....................       output_bit(m1p2, 1); 
....................       output_bit(m2p1, 0); 
....................       output_bit(m2p2, 1); 
.................... } 
....................  
.................... void esquerda_tras() 
.................... { 
....................       output_bit(m1p1, 0); 
....................       output_bit(m1p2, 1); 
....................       output_bit(m2p1, 0); 
....................       output_bit(m2p2, 0); 
.................... } 
....................  
.................... void direita_tras() 
.................... { 
....................       output_bit(m1p1, 0); 
....................       output_bit(m1p2, 0); 
....................       output_bit(m2p1, 1); 
....................       output_bit(m2p2, 0); 
.................... } 
....................  
.................... void direita_frente() 
.................... { 
....................       output_bit(m1p1, 0); 
....................       output_bit(m1p2, 0); 
....................       output_bit(m2p1, 0); 
....................       output_bit(m2p2, 1); 
.................... } 
....................  
.................... void esquerda_frente() 
.................... { 
....................       output_bit(m1p1, 1); 
....................       output_bit(m1p2, 0); 
....................       output_bit(m2p1, 0); 
....................       output_bit(m2p2, 0); 
.................... } 
....................  
.................... void para() 
.................... { 
....................       output_bit(m1p1, 0); 
....................       output_bit(m1p2, 0); 
....................       output_bit(m2p1, 0); 
....................       output_bit(m2p2, 0); 
.................... } 
....................  
.................... void MotorInitialize() 
.................... { 
....................       setup_timer_2(T2_DIV_BY_16, 255, 1); //341 us overflow, 341 us interrupt 
*
18B4:  MOVLW  00
18B6:  IORLW  06
18B8:  MOVWF  FCA
18BA:  MOVLW  FF
18BC:  MOVWF  FCB
....................  
....................       setup_ccp1(CCP_PWM | CCP_SHUTDOWN_AC_L | CCP_SHUTDOWN_BD_L); 
18BE:  BCF    F94.2
18C0:  BCF    F8B.2
18C2:  MOVLW  0C
18C4:  MOVWF  FBD
18C6:  CLRF   FB7
18C8:  CLRF   FB6
....................       setup_ccp2(CCP_PWM); 
18CA:  BCF    F94.1
18CC:  BCF    F8B.1
18CE:  MOVWF  FBA
18D0:  GOTO   1912 (RETURN)
.................... } 
....................  
.................... void SetBothPwm(int16 vel) 
.................... { 
....................       set_pwm1_duty((int16)vel); 
*
1544:  MOVFF  37,02
1548:  MOVFF  36,01
154C:  RRCF   02,F
154E:  RRCF   01,F
1550:  RRCF   02,F
1552:  RRCF   01,F
1554:  RRCF   02,F
1556:  MOVFF  01,FBE
155A:  RRCF   02,F
155C:  RRCF   02,W
155E:  ANDLW  30
1560:  MOVWF  00
1562:  MOVF   FBD,W
1564:  ANDLW  CF
1566:  IORWF  00,W
1568:  MOVWF  FBD
....................       set_pwm2_duty((int16)vel); //-50); 
156A:  MOVFF  37,02
156E:  MOVFF  36,01
1572:  RRCF   02,F
1574:  RRCF   01,F
1576:  RRCF   02,F
1578:  RRCF   01,F
157A:  RRCF   02,F
157C:  MOVFF  01,FBB
1580:  RRCF   02,F
1582:  RRCF   02,W
1584:  ANDLW  30
1586:  MOVWF  00
1588:  MOVF   FBA,W
158A:  ANDLW  CF
158C:  IORWF  00,W
158E:  MOVWF  FBA
1590:  RETURN 0
.................... } 
....................  
.................... void SetRight(int16 vel) 
.................... { 
....................       set_pwm1_duty((int16)vel); 
*
14F4:  MOVFF  37,02
14F8:  MOVFF  36,01
14FC:  RRCF   02,F
14FE:  RRCF   01,F
1500:  RRCF   02,F
1502:  RRCF   01,F
1504:  RRCF   02,F
1506:  MOVFF  01,FBE
150A:  RRCF   02,F
150C:  RRCF   02,W
150E:  ANDLW  30
1510:  MOVWF  00
1512:  MOVF   FBD,W
1514:  ANDLW  CF
1516:  IORWF  00,W
1518:  MOVWF  FBD
151A:  RETURN 0
.................... } 
.................... void SetLeft(int16 vel) 
.................... { 
....................       set_pwm2_duty((int16)vel); 
151C:  MOVFF  37,02
1520:  MOVFF  36,01
1524:  RRCF   02,F
1526:  RRCF   01,F
1528:  RRCF   02,F
152A:  RRCF   01,F
152C:  RRCF   02,F
152E:  MOVFF  01,FBB
1532:  RRCF   02,F
1534:  RRCF   02,W
1536:  ANDLW  30
1538:  MOVWF  00
153A:  MOVF   FBA,W
153C:  ANDLW  CF
153E:  IORWF  00,W
1540:  MOVWF  FBA
1542:  RETURN 0
.................... } 
....................  
.................... #include <LCD_KIT.c> 
.................... /************************************************************************/ 
.................... /*  MOD_LCD.C - Biblioteca de manipula��o de m�dulo LCD                 */ 
.................... /*                                                                      */ 
.................... /*  Autor: F�bio Pereira                                                */ 
.................... /*                                                                      */ 
.................... /************************************************************************/ 
.................... /* 
.................... lcd_cursor_on()                        fun��es LCD 
.................... lcd_cursor_pisca() 
.................... lcd_cursor_off() 
.................... lcd_corre_esquerda() 
.................... lcd_corre_direita() 
.................... lcd_envia_nibble( byte dado ) 
.................... lcd_le_byte() 
.................... lcd_ini() 
.................... lcd_pos_xy( byte x, byte y) 
.................... lcd_escreve( char c)                  \f  Clear display                            //// 
....................                                             \n  Go to start of second line               //// 
....................                                   \b  Move back one position                   //// 
....................  
.................... lcd_le( byte x, byte y) 
.................... lcd_apaga() 
.................... { 
....................  
.................... */ 
.................... // As defini��es a seguir s�o utilizadas para acesso aos pinos do display 
.................... // caso o pino RW n�o seja utilizado, comente a defini��o lcd_rw 
.................... #ifndef lcd_enable 
....................    #define lcd_rs         pin_d2      // pino rs do LCD 
....................    #define lcd_enable     pin_d3      // pino enable do LCD 
....................    #define lcd_d4         pin_d4      // pino de dados d4 do LCD 
....................    #define lcd_d5         pin_d5      // pino de dados d5 do LCD 
....................    #define lcd_d6         pin_d6      // pino de dados d6 do LCD 
....................    #define lcd_d7         pin_d7   // pino de dados d7 do LCD 
.................... #endif 
....................  
.................... #define lcd_type 2           // 0=5x7, 1=5x10, 2=2 linhas 
.................... #define lcd_seg_lin 0x40    // Endere�o da segunda linha na RAM do LCD 
....................  
.................... // a constante abaixo define a seq��ncia de inicializa��o do m�dulo LCD 
.................... byte CONST INI_LCD[4] = {0x20 | (lcd_type << 2), 0xc, 1, 6}; 
....................  
.................... /*   O 0x20 eh p configurar o tipo do display e talz. 
....................    O Segundo numero configura o modo do cursor, sendo: 
....................                -> 0xf Cursor piscante 
....................                -> 0xe Cursor comum 
....................                -> 0xc Sem cursor 
....................    O terceiro (1) limpa o display 
....................    O Quarto volta com o cursor. 
.................... */ 
....................  
.................... byte lcd_le_byte() 
.................... // l� um byte do LCD (somente com pino RW) 
.................... { 
....................    byte dado; 
....................    // configura os pinos de dados como entradas 
....................    input(lcd_d4); 
....................    input(lcd_d5); 
....................    input(lcd_d6); 
....................    input(lcd_d7); 
....................    // se o pino rw for utilizado, coloca em 1 
....................    #ifdef lcd_rw 
....................       output_high(lcd_rw); 
....................    #endif 
....................    output_high(lcd_enable); // habilita display 
....................    dado = 0;   // zera a vari�vel de leitura 
....................    // l� os quatro bits mais significativos 
....................    if (input(lcd_d7)) bit_set(dado,7); 
....................    if (input(lcd_d6)) bit_set(dado,6); 
....................    if (input(lcd_d5)) bit_set(dado,5); 
....................    if (input(lcd_d4)) bit_set(dado,4); 
....................    // d� um pulso na linha enable 
....................    output_low(lcd_enable); 
....................    output_high(lcd_enable); 
....................    // l� os quatro bits menos significativos 
....................    if (input(lcd_d7)) bit_set(dado,3); 
....................    if (input(lcd_d6)) bit_set(dado,2); 
....................    if (input(lcd_d5)) bit_set(dado,1); 
....................    if (input(lcd_d4)) bit_set(dado,0); 
....................    output_low(lcd_enable);   // desabilita o display 
....................    return dado;   // retorna o byte lido 
.................... } 
....................  
.................... void lcd_envia_nibble( byte dado ) 
.................... // envia um dado de quatro bits para o display 
.................... { 
....................    // coloca os quatro bits nas saidas 
....................    output_bit(lcd_d4,bit_test(dado,0)); 
*
10D4:  BTFSC  47.0
10D6:  BRA    10DC
10D8:  BCF    F8C.4
10DA:  BRA    10DE
10DC:  BSF    F8C.4
10DE:  BCF    F95.4
....................    output_bit(lcd_d5,bit_test(dado,1)); 
10E0:  BTFSC  47.1
10E2:  BRA    10E8
10E4:  BCF    F8C.5
10E6:  BRA    10EA
10E8:  BSF    F8C.5
10EA:  BCF    F95.5
....................    output_bit(lcd_d6,bit_test(dado,2)); 
10EC:  BTFSC  47.2
10EE:  BRA    10F4
10F0:  BCF    F8C.6
10F2:  BRA    10F6
10F4:  BSF    F8C.6
10F6:  BCF    F95.6
....................    output_bit(lcd_d7,bit_test(dado,3)); 
10F8:  BTFSC  47.3
10FA:  BRA    1100
10FC:  BCF    F8C.7
10FE:  BRA    1102
1100:  BSF    F8C.7
1102:  BCF    F95.7
....................    // d� um pulso na linha enable 
....................    output_high(lcd_enable); 
1104:  BCF    F95.3
1106:  BSF    F8C.3
....................    output_low(lcd_enable); 
1108:  BCF    F95.3
110A:  BCF    F8C.3
110C:  RETURN 0
.................... } 
....................  
....................  
.................... void lcd_envia_byte( boolean endereco, byte dado ) 
.................... { 
....................    // coloca a linha rs em 0 
....................    output_low(lcd_rs); 
110E:  BCF    F95.2
1110:  BCF    F8C.2
....................    // aguarda o display ficar desocupado 
....................    //while ( bit_test(lcd_le_byte(),7) ) ; 
....................    // configura a linha rs dependendo do modo selecionado 
....................    output_bit(lcd_rs,endereco); 
1112:  MOVF   44,F
1114:  BNZ   111A
1116:  BCF    F8C.2
1118:  BRA    111C
111A:  BSF    F8C.2
111C:  BCF    F95.2
....................    delay_us(100);   // aguarda 100 us 
111E:  MOVLW  64
1120:  MOVWF  46
1122:  RCALL  10B4
....................    // caso a linha rw esteja definida, coloca em 0 
....................    #ifdef lcd_rw 
....................       output_low(lcd_rw); 
....................    #endif 
....................    // desativa linha enable 
....................    output_low(lcd_enable); 
1124:  BCF    F95.3
1126:  BCF    F8C.3
....................    // envia a primeira parte do byte 
....................    lcd_envia_nibble(dado >> 4); 
1128:  SWAPF  45,W
112A:  MOVWF  46
112C:  MOVLW  0F
112E:  ANDWF  46,F
1130:  MOVFF  46,47
1134:  RCALL  10D4
....................    // envia a segunda parte do byte 
....................    lcd_envia_nibble(dado & 0x0f); 
1136:  MOVF   45,W
1138:  ANDLW  0F
113A:  MOVWF  46
113C:  MOVWF  47
113E:  RCALL  10D4
1140:  RETURN 0
.................... } 
....................  
....................  
.................... void lcd_ini() 
.................... // rotina de inicializa��o do display 
.................... { 
....................    byte conta; 
....................    output_low(lcd_d4); 
*
1812:  BCF    F95.4
1814:  BCF    F8C.4
....................    output_low(lcd_d5); 
1816:  BCF    F95.5
1818:  BCF    F8C.5
....................    output_low(lcd_d6); 
181A:  BCF    F95.6
181C:  BCF    F8C.6
....................    output_low(lcd_d7); 
181E:  BCF    F95.7
1820:  BCF    F8C.7
....................    output_low(lcd_rs); 
1822:  BCF    F95.2
1824:  BCF    F8C.2
....................    #ifdef lcd_rw 
....................       output_high(lcd_rw); 
....................    #endif 
....................    output_low(lcd_enable); 
1826:  BCF    F95.3
1828:  BCF    F8C.3
182A:  CLRF   16
182C:  BTFSC  FF2.7
182E:  BSF    16.7
1830:  BCF    FF2.7
....................    delay_ms(15); 
1832:  MOVLW  0F
1834:  MOVWF  40
1836:  RCALL  1142
1838:  BTFSC  16.7
183A:  BSF    FF2.7
....................    // envia uma seq��ncia de 3 vezes 0x03 
....................    // e depois 0x02 para configurar o m�dulo 
....................    // para modo de 4 bits 
....................    for(conta=1;conta<=3;++conta) 
183C:  MOVLW  01
183E:  MOVWF  23
1840:  MOVF   23,W
1842:  SUBLW  03
1844:  BNC   186E
1846:  CLRF   16
1848:  BTFSC  FF2.7
184A:  BSF    16.7
184C:  BCF    FF2.7
....................    { 
....................       lcd_envia_nibble(3); 
184E:  MOVLW  03
1850:  MOVWF  47
1852:  RCALL  10D4
1854:  BTFSC  16.7
1856:  BSF    FF2.7
1858:  CLRF   16
185A:  BTFSC  FF2.7
185C:  BSF    16.7
185E:  BCF    FF2.7
....................       delay_ms(5); 
1860:  MOVLW  05
1862:  MOVWF  40
1864:  RCALL  1142
1866:  BTFSC  16.7
1868:  BSF    FF2.7
186A:  INCF   23,F
186C:  BRA    1840
186E:  CLRF   16
1870:  BTFSC  FF2.7
1872:  BSF    16.7
1874:  BCF    FF2.7
....................    } 
....................    lcd_envia_nibble(2); 
1876:  MOVLW  02
1878:  MOVWF  47
187A:  RCALL  10D4
187C:  BTFSC  16.7
187E:  BSF    FF2.7
....................    // envia string de inicializa��o do display 
....................    for(conta=0;conta<=3;++conta) lcd_envia_byte(0,INI_LCD[conta]); 
1880:  CLRF   23
1882:  MOVF   23,W
1884:  SUBLW  03
1886:  BNC   18B0
1888:  CLRF   03
188A:  MOVF   23,W
188C:  MOVFF  FF2,24
1890:  BCF    FF2.7
1892:  RCALL  1096
1894:  BTFSC  24.7
1896:  BSF    FF2.7
1898:  MOVWF  24
189A:  CLRF   16
189C:  BTFSC  FF2.7
189E:  BSF    16.7
18A0:  BCF    FF2.7
18A2:  CLRF   44
18A4:  MOVWF  45
18A6:  RCALL  110E
18A8:  BTFSC  16.7
18AA:  BSF    FF2.7
18AC:  INCF   23,F
18AE:  BRA    1882
18B0:  GOTO   1910 (RETURN)
.................... } 
....................  
.................... void lcd_pos_xy( byte x, byte y) 
.................... { 
....................    byte endereco; 
....................    if(y!=1) 
*
116A:  DECFSZ 41,W
116C:  BRA    1170
116E:  BRA    1176
....................       endereco = lcd_seg_lin; 
1170:  MOVLW  40
1172:  MOVWF  42
1174:  BRA    1178
....................    else 
....................       endereco = 0; 
1176:  CLRF   42
....................    endereco += x-1; 
1178:  MOVLW  01
117A:  SUBWF  40,W
117C:  ADDWF  42,F
....................    lcd_envia_byte(0,0x80|endereco); 
117E:  MOVF   42,W
1180:  IORLW  80
1182:  MOVWF  43
1184:  CLRF   44
1186:  MOVWF  45
1188:  RCALL  110E
118A:  RETURN 0
.................... } 
....................  
.................... void lcd_escreve( char c) 
.................... // envia caractere para o display 
.................... { 
....................    switch (c) 
118C:  MOVF   3F,W
118E:  XORLW  0C
1190:  BZ    11A0
1192:  XORLW  06
1194:  BZ    11B0
1196:  XORLW  07
1198:  BZ    11B0
119A:  XORLW  05
119C:  BZ    11BC
119E:  BRA    11C6
....................    { 
....................      case '\f'    :   lcd_envia_byte(0,1); 
11A0:  CLRF   44
11A2:  MOVLW  01
11A4:  MOVWF  45
11A6:  RCALL  110E
....................               delay_ms(2); 
11A8:  MOVLW  02
11AA:  MOVWF  40
11AC:  RCALL  1142
....................             break; 
11AE:  BRA    11D0
....................      case '\n'   : 
....................      case '\r'    :   lcd_pos_xy(1,2); 
11B0:  MOVLW  01
11B2:  MOVWF  40
11B4:  MOVLW  02
11B6:  MOVWF  41
11B8:  RCALL  116A
....................               break; 
11BA:  BRA    11D0
....................      case '\b'    :   lcd_envia_byte(0,0x10); 
11BC:  CLRF   44
11BE:  MOVLW  10
11C0:  MOVWF  45
11C2:  RCALL  110E
....................               break; 
11C4:  BRA    11D0
....................      default   :   lcd_envia_byte(1,c); 
11C6:  MOVLW  01
11C8:  MOVWF  44
11CA:  MOVFF  3F,45
11CE:  RCALL  110E
....................               break; 
....................    } 
11D0:  RETURN 0
.................... } 
....................  
.................... char lcd_le( byte x, byte y) 
.................... // le caractere do display 
.................... { 
....................    char valor; 
....................    // seleciona a posi��o do caractere 
....................    lcd_pos_xy(x,y); 
....................    // ativa rs 
....................    output_high(lcd_rs); 
....................    // l� o caractere 
....................    valor = lcd_le_byte(); 
....................    // desativa rs 
....................    output_low(lcd_rs); 
....................    // retorna o valor do caractere 
....................    return valor; 
.................... } 
....................  
.................... void lcd_apaga() 
.................... { 
....................    lcd_envia_byte(0,1); 
....................    delay_ms(2); 
.................... } 
....................  
.................... void lcd_cursor_on() 
....................     { 
.................... lcd_envia_byte(0,0x0E); 
....................     } 
....................  
.................... void lcd_cursor_pisca() 
....................     { 
.................... lcd_envia_byte(0,0x0F); 
....................     } 
....................  
.................... void lcd_cursor_off() 
....................     { 
....................  lcd_envia_byte(0,0x0C); 
....................     } 
....................  
.................... void lcd_corre_esquerda() 
....................     { 
....................  lcd_envia_byte(0,0x18); 
....................     } 
....................  
.................... void lcd_corre_direita() 
....................     { 
.................... lcd_envia_byte(0,0x1C); 
....................     } 
....................  
....................  
....................  
.................... #define button1 pin_a4 
.................... #define button2 pin_a5 
.................... #define button3 pin_e0 
.................... #define button4 pin_e1 
....................  
.................... int running; 
....................  
.................... int16 ad1, ad2, ad3, ad4; 
.................... int16 timerBase; 
.................... int8 adCounter; 
....................  
.................... void ClearScreen(); 
.................... void Setup(); 
....................  
.................... #int_timer0 
.................... void timerTick() 
.................... { 
....................     if (adCounter == 1) 
*
1592:  DECFSZ 22,W
1594:  BRA    15A6
....................     { 
....................         ad1 = read_adc(); 
1596:  BSF    FC2.1
1598:  BTFSC  FC2.1
159A:  BRA    1598
159C:  MOVFF  FC3,18
15A0:  MOVFF  FC4,19
....................     } 
15A4:  BRA    15E2
....................     else if (adCounter == 2) 
15A6:  MOVF   22,W
15A8:  SUBLW  02
15AA:  BNZ   15BC
....................     { 
....................         ad2 = read_adc(); 
15AC:  BSF    FC2.1
15AE:  BTFSC  FC2.1
15B0:  BRA    15AE
15B2:  MOVFF  FC3,1A
15B6:  MOVFF  FC4,1B
....................     } 
15BA:  BRA    15E2
....................     else if (adCounter == 3) 
15BC:  MOVF   22,W
15BE:  SUBLW  03
15C0:  BNZ   15D2
....................     { 
....................         ad3 = read_adc(); 
15C2:  BSF    FC2.1
15C4:  BTFSC  FC2.1
15C6:  BRA    15C4
15C8:  MOVFF  FC3,1C
15CC:  MOVFF  FC4,1D
....................     } 
15D0:  BRA    15E2
....................     else 
....................     { 
....................         adCounter = 0; 
15D2:  CLRF   22
....................         ad4 = read_adc(); 
15D4:  BSF    FC2.1
15D6:  BTFSC  FC2.1
15D8:  BRA    15D6
15DA:  MOVFF  FC3,1E
15DE:  MOVFF  FC4,1F
....................     } 
....................     if (timerBase == 2000) 
15E2:  MOVF   20,W
15E4:  SUBLW  D0
15E6:  BNZ   1624
15E8:  MOVF   21,W
15EA:  SUBLW  07
15EC:  BNZ   1624
....................     { 
....................         timerBase = 0; 
15EE:  CLRF   21
15F0:  CLRF   20
....................         ClearScreen(); 
15F2:  BRA    11D2
....................         printf(lcd_escreve, "1: "); 
15F4:  MOVLW  CE
15F6:  MOVWF  FF6
15F8:  MOVLW  17
15FA:  MOVWF  FF7
15FC:  RCALL  11DC
....................         printf(lcd_escreve, "%04ld", ad1); 
15FE:  MOVLW  0A
1600:  MOVWF  FE9
1602:  MOVFF  19,37
1606:  MOVFF  18,36
160A:  RCALL  11FC
....................         printf(lcd_escreve, " 2: "); 
160C:  MOVLW  D2
160E:  MOVWF  FF6
1610:  MOVLW  17
1612:  MOVWF  FF7
1614:  RCALL  11DC
....................         printf(lcd_escreve, "%04ld", ad2); 
1616:  MOVLW  0A
1618:  MOVWF  FE9
161A:  MOVFF  1B,37
161E:  MOVFF  1A,36
1622:  RCALL  11FC
....................         // lcd_pos_xy(1, 2); 
....................         // printf(lcd_escreve, "3: "); 
....................         // printf(lcd_escreve, "%04ld", ad3); 
....................         // printf(lcd_escreve, " 4: "); 
....................         // printf(lcd_escreve, "%04ld", ad4); 
....................     } 
....................     timerBase++; 
1624:  INCF   20,F
1626:  BTFSC  FD8.2
1628:  INCF   21,F
....................     adCounter++; 
162A:  INCF   22,F
....................  
....................     set_adc_channel(adCounter); 
162C:  RLCF   22,W
162E:  MOVWF  00
1630:  RLCF   00,F
1632:  MOVLW  FC
1634:  ANDWF  00,F
1636:  MOVF   FC2,W
1638:  ANDLW  C3
163A:  IORWF  00,W
163C:  MOVWF  FC2
.................... #ifdef DEBUG 
....................     SetLeft(0); 
....................     SetRight(1023); 
.................... #else 
....................     if (running == 1) 
163E:  DECFSZ 17,W
1640:  BRA    17C2
....................     { 
....................         float ad1Ratio = (float)ad1 / (float)(ad1 + ad2); 
....................         float ad2Ratio = (float)ad2 / (float)(ad1 + ad2); 
1642:  MOVFF  19,3B
1646:  MOVFF  18,3A
164A:  RCALL  12EE
164C:  MOVFF  03,39
1650:  MOVFF  02,38
1654:  MOVFF  01,37
1658:  MOVFF  00,36
165C:  MOVF   1A,W
165E:  ADDWF  18,W
1660:  MOVWF  01
1662:  MOVF   1B,W
1664:  ADDWFC 19,W
1666:  MOVWF  03
1668:  MOVFF  01,3A
166C:  MOVWF  3B
166E:  RCALL  12EE
1670:  MOVFF  39,3D
1674:  MOVFF  38,3C
1678:  MOVFF  37,3B
167C:  MOVFF  36,3A
1680:  MOVFF  03,41
1684:  MOVFF  02,40
1688:  MOVFF  01,3F
168C:  MOVFF  00,3E
1690:  RCALL  1324
1692:  MOVFF  03,31
1696:  MOVFF  02,30
169A:  MOVFF  01,2F
169E:  MOVFF  00,2E
16A2:  MOVFF  1B,3B
16A6:  MOVFF  1A,3A
16AA:  RCALL  12EE
16AC:  MOVFF  03,39
16B0:  MOVFF  02,38
16B4:  MOVFF  01,37
16B8:  MOVFF  00,36
16BC:  MOVF   1A,W
16BE:  ADDWF  18,W
16C0:  MOVWF  01
16C2:  MOVF   1B,W
16C4:  ADDWFC 19,W
16C6:  MOVWF  03
16C8:  MOVFF  01,3A
16CC:  MOVWF  3B
16CE:  RCALL  12EE
16D0:  MOVFF  39,3D
16D4:  MOVFF  38,3C
16D8:  MOVFF  37,3B
16DC:  MOVFF  36,3A
16E0:  MOVFF  03,41
16E4:  MOVFF  02,40
16E8:  MOVFF  01,3F
16EC:  MOVFF  00,3E
16F0:  RCALL  1324
16F2:  MOVFF  03,35
16F6:  MOVFF  02,34
16FA:  MOVFF  01,33
16FE:  MOVFF  00,32
....................  
....................         ///alto significa escuro 
....................         if (ad1 + ad2 > 300) 
1702:  MOVF   1A,W
1704:  ADDWF  18,W
1706:  MOVWF  36
1708:  MOVF   1B,W
170A:  ADDWFC 19,W
170C:  MOVWF  37
170E:  SUBLW  00
1710:  BC    17AC
1712:  XORLW  FF
1714:  BNZ   171C
1716:  MOVF   36,W
1718:  SUBLW  2C
171A:  BC    17AC
....................         { 
....................             //Como quanto mais escuro mais alto, isso significa que o que esta com menos tem que subir, 
....................             //e vai subir proporcionalmente a quanto a menos ele tem, esse valor é exatamente o oposto (que esta no outro ad) 
....................  
....................             lcd_pos_xy(1, 2); 
171C:  MOVLW  01
171E:  MOVWF  40
1720:  MOVLW  02
1722:  MOVWF  41
1724:  RCALL  116A
....................  
....................             //O ad1 é o da direita, se este esta maior, significa que o robo esta a direit 
....................             if (ad1Ratio > 0.55f) 
1726:  MOVLW  CD
1728:  MOVWF  39
172A:  MOVLW  CC
172C:  MOVWF  38
172E:  MOVLW  0C
1730:  MOVWF  37
1732:  MOVLW  7E
1734:  MOVWF  36
1736:  MOVFF  31,3D
173A:  MOVFF  30,3C
173E:  MOVFF  2F,3B
1742:  MOVFF  2E,3A
1746:  RCALL  147E
1748:  BNC   1764
....................             { 
....................                 printf(lcd_escreve, "Esta a direita"); 
174A:  MOVLW  D8
174C:  MOVWF  FF6
174E:  MOVLW  17
1750:  MOVWF  FF7
1752:  RCALL  11DC
....................                 SetRight(1023); 
1754:  MOVLW  03
1756:  MOVWF  37
1758:  SETF   36
175A:  RCALL  14F4
....................                 SetLeft(0); 
175C:  CLRF   37
175E:  CLRF   36
1760:  RCALL  151C
....................             } 
1762:  BRA    17AA
....................             else if (ad2Ratio > 0.55f) 
1764:  MOVLW  CD
1766:  MOVWF  39
1768:  MOVLW  CC
176A:  MOVWF  38
176C:  MOVLW  0C
176E:  MOVWF  37
1770:  MOVLW  7E
1772:  MOVWF  36
1774:  MOVFF  35,3D
1778:  MOVFF  34,3C
177C:  MOVFF  33,3B
1780:  MOVFF  32,3A
1784:  RCALL  147E
1786:  BNC   17A2
....................             { 
....................                 printf(lcd_escreve, "Esta a esquerda"); 
1788:  MOVLW  E8
178A:  MOVWF  FF6
178C:  MOVLW  17
178E:  MOVWF  FF7
1790:  RCALL  11DC
....................                 SetRight(0); 
1792:  CLRF   37
1794:  CLRF   36
1796:  RCALL  14F4
....................                 SetLeft(1023); 
1798:  MOVLW  03
179A:  MOVWF  37
179C:  SETF   36
179E:  RCALL  151C
....................             } 
17A0:  BRA    17AA
....................             else 
....................             { 
....................                 SetBothPwm(1023); 
17A2:  MOVLW  03
17A4:  MOVWF  37
17A6:  SETF   36
17A8:  RCALL  1544
....................             } 
....................         } 
17AA:  BRA    17C0
....................         else 
....................         { 
....................             ///Esta fora da pista, deve fazer algo 
....................             //SetBothPwm(0); 
....................             lcd_pos_xy(1, 2); 
17AC:  MOVLW  01
17AE:  MOVWF  40
17B0:  MOVLW  02
17B2:  MOVWF  41
17B4:  RCALL  116A
....................  
....................             printf(lcd_escreve, "Se perdeu"); 
17B6:  MOVLW  F8
17B8:  MOVWF  FF6
17BA:  MOVLW  17
17BC:  MOVWF  FF7
17BE:  RCALL  11DC
....................              
....................         } 
....................     } 
17C0:  BRA    17C8
....................  
....................     else 
....................     { 
....................         SetBothPwm(0); 
17C2:  CLRF   37
17C4:  CLRF   36
17C6:  RCALL  1544
....................     } 
.................... #endif 
17C8:  BCF    FF2.2
17CA:  GOTO   1054
.................... } 
....................  
.................... void main() 
*
192C:  CLRF   FF8
192E:  BCF    FD0.7
1930:  BSF    07.7
1932:  MOVF   FC1,W
1934:  ANDLW  C0
1936:  IORLW  0F
1938:  MOVWF  FC1
193A:  MOVLW  07
193C:  MOVWF  FB4
.................... { 
....................     Setup(); 
193E:  BRA    18E8
1940:  CLRF   16
1942:  BTFSC  FF2.7
1944:  BSF    16.7
1946:  BCF    FF2.7
....................     lcd_pos_xy(1, 1); 
1948:  MOVLW  01
194A:  MOVWF  40
194C:  MOVWF  41
194E:  RCALL  116A
1950:  BTFSC  16.7
1952:  BSF    FF2.7
1954:  CLRF   16
1956:  BTFSC  FF2.7
1958:  BSF    16.7
195A:  BCF    FF2.7
....................     delay_ms(5); 
195C:  MOVLW  05
195E:  MOVWF  40
1960:  CALL   1142
1964:  BTFSC  16.7
1966:  BSF    FF2.7
....................     printf(lcd_escreve, " Inicializando"); 
1968:  MOVLW  02
196A:  MOVWF  FF6
196C:  MOVLW  18
196E:  MOVWF  FF7
1970:  CLRF   16
1972:  BTFSC  FF2.7
1974:  BSF    16.7
1976:  BCF    FF2.7
1978:  RCALL  11DC
197A:  BTFSC  16.7
197C:  BSF    FF2.7
....................     delay_ms(1000); 
197E:  MOVLW  04
1980:  MOVWF  23
1982:  CLRF   16
1984:  BTFSC  FF2.7
1986:  BSF    16.7
1988:  BCF    FF2.7
198A:  MOVLW  FA
198C:  MOVWF  40
198E:  CALL   1142
1992:  BTFSC  16.7
1994:  BSF    FF2.7
1996:  DECFSZ 23,F
1998:  BRA    1982
....................     do 
....................     { 
....................         if (input(button1) == 0) 
199A:  BSF    F92.4
199C:  BTFSC  F80.4
199E:  BRA    19A4
....................         { 
....................             running = 1; 
19A0:  MOVLW  01
19A2:  MOVWF  17
....................         } 
....................         if (input(button2) == 0) 
19A4:  BSF    F92.5
19A6:  BTFSC  F80.5
19A8:  BRA    19AC
....................         { 
....................             running = 0; 
19AA:  CLRF   17
....................         } 
....................     } while (1); 
19AC:  BRA    199A
.................... } 
....................  
19AE:  SLEEP 
.................... void Setup() 
.................... { 
....................     adCounter = 1; 
*
18E8:  MOVLW  01
18EA:  MOVWF  22
....................     running = 0; 
18EC:  CLRF   17
....................  
....................     setup_adc_ports(AN0_TO_AN3); 
18EE:  MOVF   FC1,W
18F0:  ANDLW  C0
18F2:  IORLW  0B
18F4:  MOVWF  FC1
....................     setup_adc(ADC_CLOCK_DIV_4); 
18F6:  MOVF   FC0,W
18F8:  ANDLW  C0
18FA:  IORLW  04
18FC:  MOVWF  FC0
18FE:  BSF    FC0.7
1900:  BSF    FC2.0
....................  
....................     setup_timer_0(RTCC_INTERNAL | RTCC_DIV_2 | RTCC_8_BIT); 
1902:  MOVLW  C0
1904:  MOVWF  FD5
....................     set_timer0(0); 
1906:  CLRF   FD7
1908:  CLRF   FD6
....................     enable_interrupts(INT_TIMER0); 
190A:  BSF    FF2.5
....................     enable_interrupts(GLOBAL); 
190C:  IORWF  FF2,F
....................  
....................     lcd_ini(); 
190E:  BRA    1812
....................     MotorInitialize(); 
1910:  BRA    18B4
1912:  CLRF   16
1914:  BTFSC  FF2.7
1916:  BSF    16.7
1918:  BCF    FF2.7
....................     SetBothPwm(1023); 
191A:  MOVLW  03
191C:  MOVWF  37
191E:  SETF   36
1920:  RCALL  1544
1922:  BTFSC  16.7
1924:  BSF    FF2.7
....................     frente(); 
1926:  BRA    18D4
1928:  GOTO   1940 (RETURN)
.................... } 
....................  
.................... void ClearScreen() 
.................... { 
....................     lcd_escreve('\f'); 
*
11D2:  MOVLW  0C
11D4:  MOVWF  3F
11D6:  RCALL  118C
11D8:  GOTO   15F4 (RETURN)
.................... } 

Configuration Fuses:
   Word  1: CE24   PLL5 CPUDIV1 USBDIV HSPLL FCMEN IESO
   Word  2: 0E38   PUT NOBROWNOUT BORV21 VREGEN NOWDT WDT128
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
