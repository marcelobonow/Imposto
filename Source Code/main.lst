CCS PCH C Compiler, Version 5.015, 5967               20-ago-18 00:19

               Filename:   D:\Projetos\Imposto\Source Code\main.lst

               ROM used:   1430 bytes (4%)
                           Largest free fragment is 27238
               RAM used:   24 (1%) at main() level
                           43 (2%) worst case
               Stack used: 7 locations (6 in main + 1 for interrupts)
               Stack size: 31

*
1000:  GOTO   14CA
*
1008:  MOVWF  04
100A:  MOVFF  FD8,05
100E:  MOVFF  FE0,06
1012:  MOVLB  0
1014:  MOVFF  FE9,0C
1018:  MOVFF  FEA,07
101C:  MOVFF  FE1,08
1020:  MOVFF  FE2,09
1024:  MOVFF  FD9,0A
1028:  MOVFF  FDA,0B
102C:  MOVFF  FF3,12
1030:  MOVFF  FF4,13
1034:  MOVFF  FFA,14
1038:  MOVFF  00,0E
103C:  MOVFF  01,0F
1040:  MOVFF  02,10
1044:  MOVFF  03,11
1048:  BTFSS  FF2.5
104A:  GOTO   1054
104E:  BTFSC  FF2.2
1050:  GOTO   10C6
1054:  MOVFF  0E,00
1058:  MOVFF  0F,01
105C:  MOVFF  10,02
1060:  MOVFF  11,03
1064:  MOVFF  0C,FE9
1068:  MOVFF  07,FEA
106C:  BSF    07.7
106E:  MOVFF  08,FE1
1072:  MOVFF  09,FE2
1076:  MOVFF  0A,FD9
107A:  MOVFF  0B,FDA
107E:  MOVFF  12,FF3
1082:  MOVFF  13,FF4
1086:  MOVFF  14,FFA
108A:  MOVF   04,W
108C:  MOVFF  06,FE0
1090:  MOVFF  05,FD8
1094:  RETFIE 0
.................... #include <main.h> 
.................... #include "18F4550.h" 
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4550 
1096:  MOVFF  FF2,0D
109A:  BCF    FF2.7
109C:  CLRF   FF7
109E:  ADDLW  B0
10A0:  MOVWF  FF6
10A2:  MOVLW  10
10A4:  ADDWFC FF7,F
10A6:  TBLRD*+
10A8:  MOVF   FF5,W
10AA:  BTFSC  0D.7
10AC:  BSF    FF2.7
10AE:  RETURN 0
10B0:  DATA 28,0C
10B2:  DATA 01,06
10B4:  DATA 20,20
10B6:  DATA 20,20
10B8:  DATA 20,20
10BA:  DATA 20,20
10BC:  DATA 20,20
10BE:  DATA 20,20
10C0:  DATA 20,20
10C2:  DATA 20,20
10C4:  DATA 00,00
*
10CC:  DATA 20,49
10CE:  DATA 6E,69
10D0:  DATA 63,69
10D2:  DATA 61,6C
10D4:  DATA 69,7A
10D6:  DATA 61,6E
10D8:  DATA 64,6F
10DA:  DATA 00,00
10DC:  DATA 4D,61
10DE:  DATA 69,6F
10E0:  DATA 72,20
10E2:  DATA 71,75
10E4:  DATA 65,20
10E6:  DATA 39,33
10E8:  DATA 30,36
10EA:  DATA 00,00
10EC:  DATA 4D,65
10EE:  DATA 6E,6F
10F0:  DATA 72,20
10F2:  DATA 71,75
10F4:  DATA 65,20
10F6:  DATA 39,33
10F8:  DATA 30,36
10FA:  DATA 00,00
10FC:  DATA 31,3A
10FE:  DATA 20,00
*
12B0:  TBLRD*+
12B2:  MOVF   FF5,F
12B4:  BZ    12CE
12B6:  MOVFF  FF6,1E
12BA:  MOVFF  FF7,1F
12BE:  MOVFF  FF5,20
12C2:  RCALL  126A
12C4:  MOVFF  1E,FF6
12C8:  MOVFF  1F,FF7
12CC:  BRA    12B0
12CE:  RETURN 0
*
12FA:  CLRF   01
12FC:  CLRF   02
12FE:  CLRF   00
1300:  CLRF   03
1302:  MOVF   29,W
1304:  BNZ   130A
1306:  MOVF   28,W
1308:  BZ    133A
130A:  MOVLW  10
130C:  MOVWF  2A
130E:  BCF    FD8.0
1310:  RLCF   26,F
1312:  RLCF   27,F
1314:  RLCF   00,F
1316:  RLCF   03,F
1318:  MOVF   29,W
131A:  SUBWF  03,W
131C:  BNZ   1322
131E:  MOVF   28,W
1320:  SUBWF  00,W
1322:  BNC   1332
1324:  MOVF   28,W
1326:  SUBWF  00,F
1328:  BTFSS  FD8.0
132A:  DECF   03,F
132C:  MOVF   29,W
132E:  SUBWF  03,F
1330:  BSF    FD8.0
1332:  RLCF   01,F
1334:  RLCF   02,F
1336:  DECFSZ 2A,F
1338:  BRA    130E
133A:  RETURN 0
*
14A4:  MOVF   FEF,F
14A6:  BZ    14C6
14A8:  MOVFF  FEA,1F
14AC:  MOVFF  FE9,1E
14B0:  MOVFF  FEF,20
14B4:  RCALL  126A
14B6:  MOVFF  1F,FEA
14BA:  MOVFF  1E,FE9
14BE:  INCF   FE9,F
14C0:  BTFSC  FD8.2
14C2:  INCF   FEA,F
14C4:  BRA    14A4
14C6:  GOTO   1590 (RETURN)
....................  
.................... #list 
....................  
.................... #device ADC=10 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES WDT128                   //Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOXINST                  //Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
....................  
.................... #use delay(clock=48MHz,crystal=20MHz) 
*
1100:  CLRF   FEA
1102:  MOVLW  21
1104:  MOVWF  FE9
1106:  MOVF   FEF,W
1108:  BZ    1126
110A:  MOVLW  0F
110C:  MOVWF  01
110E:  CLRF   00
1110:  DECFSZ 00,F
1112:  BRA    1110
1114:  DECFSZ 01,F
1116:  BRA    110E
1118:  MOVLW  8F
111A:  MOVWF  00
111C:  DECFSZ 00,F
111E:  BRA    111C
1120:  NOP   
1122:  DECFSZ FEF,F
1124:  BRA    110A
1126:  RETURN 0
*
1162:  MOVLW  01
1164:  SUBWF  27,F
1166:  BNC   1180
1168:  CLRF   FEA
116A:  MOVLW  27
116C:  MOVWF  FE9
116E:  MOVF   FEF,W
1170:  BZ    1180
1172:  MOVLW  02
1174:  MOVWF  00
1176:  DECFSZ 00,F
1178:  BRA    1176
117A:  BRA    117C
117C:  DECFSZ FEF,F
117E:  BRA    1172
1180:  GOTO   119A (RETURN)
....................  
.................... #build(reset=0x1000, interrupt=0x1008) 
.................... #org 0x000, 0xfff { } 
....................  
.................... #include <LCD_KIT.c> 
.................... /************************************************************************/ 
.................... /*  MOD_LCD.C - Biblioteca de manipula��o de m�dulo LCD                 */ 
.................... /*                                                                      */ 
.................... /*  Autor: F�bio Pereira                                                */ 
.................... /*                                                                      */ 
.................... /************************************************************************/ 
.................... /* 
.................... lcd_cursor_on()                        fun��es LCD 
.................... lcd_cursor_pisca() 
.................... lcd_cursor_off() 
.................... lcd_corre_esquerda() 
.................... lcd_corre_direita() 
.................... lcd_envia_nibble( byte dado ) 
.................... lcd_le_byte() 
.................... lcd_ini() 
.................... lcd_pos_xy( byte x, byte y) 
.................... lcd_escreve( char c)                  \f  Clear display                            //// 
....................                                             \n  Go to start of second line               //// 
....................                                   \b  Move back one position                   //// 
....................  
.................... lcd_le( byte x, byte y) 
.................... lcd_apaga() 
.................... { 
....................  
.................... */ 
.................... // As defini��es a seguir s�o utilizadas para acesso aos pinos do display 
.................... // caso o pino RW n�o seja utilizado, comente a defini��o lcd_rw 
.................... #ifndef lcd_enable 
....................    #define lcd_rs         pin_d2      // pino rs do LCD 
....................    #define lcd_enable     pin_d3      // pino enable do LCD 
....................    #define lcd_d4         pin_d4      // pino de dados d4 do LCD 
....................    #define lcd_d5         pin_d5      // pino de dados d5 do LCD 
....................    #define lcd_d6         pin_d6      // pino de dados d6 do LCD 
....................    #define lcd_d7         pin_d7   // pino de dados d7 do LCD 
.................... #endif 
....................  
.................... #define lcd_type 2           // 0=5x7, 1=5x10, 2=2 linhas 
.................... #define lcd_seg_lin 0x40    // Endere�o da segunda linha na RAM do LCD 
....................  
.................... // a constante abaixo define a seq��ncia de inicializa��o do m�dulo LCD 
.................... byte CONST INI_LCD[4] = {0x20 | (lcd_type << 2), 0xc, 1, 6}; 
....................  
.................... /*   O 0x20 eh p configurar o tipo do display e talz. 
....................    O Segundo numero configura o modo do cursor, sendo: 
....................                -> 0xf Cursor piscante 
....................                -> 0xe Cursor comum 
....................                -> 0xc Sem cursor 
....................    O terceiro (1) limpa o display 
....................    O Quarto volta com o cursor. 
.................... */ 
....................  
.................... byte lcd_le_byte() 
.................... // l� um byte do LCD (somente com pino RW) 
.................... { 
....................    byte dado; 
....................    // configura os pinos de dados como entradas 
....................    input(lcd_d4); 
....................    input(lcd_d5); 
....................    input(lcd_d6); 
....................    input(lcd_d7); 
....................    // se o pino rw for utilizado, coloca em 1 
....................    #ifdef lcd_rw 
....................       output_high(lcd_rw); 
....................    #endif 
....................    output_high(lcd_enable); // habilita display 
....................    dado = 0;   // zera a vari�vel de leitura 
....................    // l� os quatro bits mais significativos 
....................    if (input(lcd_d7)) bit_set(dado,7); 
....................    if (input(lcd_d6)) bit_set(dado,6); 
....................    if (input(lcd_d5)) bit_set(dado,5); 
....................    if (input(lcd_d4)) bit_set(dado,4); 
....................    // d� um pulso na linha enable 
....................    output_low(lcd_enable); 
....................    output_high(lcd_enable); 
....................    // l� os quatro bits menos significativos 
....................    if (input(lcd_d7)) bit_set(dado,3); 
....................    if (input(lcd_d6)) bit_set(dado,2); 
....................    if (input(lcd_d5)) bit_set(dado,1); 
....................    if (input(lcd_d4)) bit_set(dado,0); 
....................    output_low(lcd_enable);   // desabilita o display 
....................    return dado;   // retorna o byte lido 
.................... } 
....................  
.................... void lcd_envia_nibble( byte dado ) 
.................... // envia um dado de quatro bits para o display 
.................... { 
....................    // coloca os quatro bits nas saidas 
....................    output_bit(lcd_d4,bit_test(dado,0)); 
*
1128:  BTFSC  28.0
112A:  BRA    1130
112C:  BCF    F8C.4
112E:  BRA    1132
1130:  BSF    F8C.4
1132:  BCF    F95.4
....................    output_bit(lcd_d5,bit_test(dado,1)); 
1134:  BTFSC  28.1
1136:  BRA    113C
1138:  BCF    F8C.5
113A:  BRA    113E
113C:  BSF    F8C.5
113E:  BCF    F95.5
....................    output_bit(lcd_d6,bit_test(dado,2)); 
1140:  BTFSC  28.2
1142:  BRA    1148
1144:  BCF    F8C.6
1146:  BRA    114A
1148:  BSF    F8C.6
114A:  BCF    F95.6
....................    output_bit(lcd_d7,bit_test(dado,3)); 
114C:  BTFSC  28.3
114E:  BRA    1154
1150:  BCF    F8C.7
1152:  BRA    1156
1154:  BSF    F8C.7
1156:  BCF    F95.7
....................    // d� um pulso na linha enable 
....................    output_high(lcd_enable); 
1158:  BCF    F95.3
115A:  BSF    F8C.3
....................    output_low(lcd_enable); 
115C:  BCF    F95.3
115E:  BCF    F8C.3
1160:  RETURN 0
.................... } 
....................  
....................  
.................... void lcd_envia_byte( boolean endereco, byte dado ) 
.................... { 
....................    // coloca a linha rs em 0 
....................    output_low(lcd_rs); 
*
1184:  BCF    F95.2
1186:  BCF    F8C.2
....................    // aguarda o display ficar desocupado 
....................    //while ( bit_test(lcd_le_byte(),7) ) ; 
....................    // configura a linha rs dependendo do modo selecionado 
....................    output_bit(lcd_rs,endereco); 
1188:  MOVF   25,F
118A:  BNZ   1190
118C:  BCF    F8C.2
118E:  BRA    1192
1190:  BSF    F8C.2
1192:  BCF    F95.2
....................    delay_us(100);   // aguarda 100 us 
1194:  MOVLW  64
1196:  MOVWF  27
1198:  BRA    1162
....................    // caso a linha rw esteja definida, coloca em 0 
....................    #ifdef lcd_rw 
....................       output_low(lcd_rw); 
....................    #endif 
....................    // desativa linha enable 
....................    output_low(lcd_enable); 
119A:  BCF    F95.3
119C:  BCF    F8C.3
....................    // envia a primeira parte do byte 
....................    lcd_envia_nibble(dado >> 4); 
119E:  SWAPF  26,W
11A0:  MOVWF  27
11A2:  MOVLW  0F
11A4:  ANDWF  27,F
11A6:  MOVFF  27,28
11AA:  RCALL  1128
....................    // envia a segunda parte do byte 
....................    lcd_envia_nibble(dado & 0x0f); 
11AC:  MOVF   26,W
11AE:  ANDLW  0F
11B0:  MOVWF  27
11B2:  MOVWF  28
11B4:  RCALL  1128
11B6:  RETURN 0
.................... } 
....................  
....................  
.................... void InitializeLcd() 
.................... // rotina de inicializa��o do display 
.................... { 
....................    byte conta; 
....................    output_low(lcd_d4); 
11B8:  BCF    F95.4
11BA:  BCF    F8C.4
....................    output_low(lcd_d5); 
11BC:  BCF    F95.5
11BE:  BCF    F8C.5
....................    output_low(lcd_d6); 
11C0:  BCF    F95.6
11C2:  BCF    F8C.6
....................    output_low(lcd_d7); 
11C4:  BCF    F95.7
11C6:  BCF    F8C.7
....................    output_low(lcd_rs); 
11C8:  BCF    F95.2
11CA:  BCF    F8C.2
....................    #ifdef lcd_rw 
....................       output_high(lcd_rw); 
....................    #endif 
....................    output_low(lcd_enable); 
11CC:  BCF    F95.3
11CE:  BCF    F8C.3
....................    delay_ms(15); 
11D0:  MOVLW  0F
11D2:  MOVWF  21
11D4:  RCALL  1100
....................    // envia uma seq��ncia de 3 vezes 0x03 
....................    // e depois 0x02 para configurar o m�dulo 
....................    // para modo de 4 bits 
....................    for(conta=1;conta<=3;++conta) 
11D6:  MOVLW  01
11D8:  MOVWF  1E
11DA:  MOVF   1E,W
11DC:  SUBLW  03
11DE:  BNC   11F0
....................    { 
....................       lcd_envia_nibble(3); 
11E0:  MOVLW  03
11E2:  MOVWF  28
11E4:  RCALL  1128
....................       delay_ms(5); 
11E6:  MOVLW  05
11E8:  MOVWF  21
11EA:  RCALL  1100
11EC:  INCF   1E,F
11EE:  BRA    11DA
....................    } 
....................    lcd_envia_nibble(2); 
11F0:  MOVLW  02
11F2:  MOVWF  28
11F4:  RCALL  1128
....................    // envia string de inicializa��o do display 
....................    for(conta=0;conta<=3;++conta) lcd_envia_byte(0,INI_LCD[conta]); 
11F6:  CLRF   1E
11F8:  MOVF   1E,W
11FA:  SUBLW  03
11FC:  BNC   121A
11FE:  CLRF   03
1200:  MOVF   1E,W
1202:  MOVFF  FF2,1F
1206:  BCF    FF2.7
1208:  RCALL  1096
120A:  BTFSC  1F.7
120C:  BSF    FF2.7
120E:  MOVWF  1F
1210:  CLRF   25
1212:  MOVWF  26
1214:  RCALL  1184
1216:  INCF   1E,F
1218:  BRA    11F8
121A:  GOTO   1244 (RETURN)
.................... } 
....................  
.................... void lcd_pos_xy( byte x, byte y) 
.................... { 
....................    byte endereco; 
....................    if(y!=1) 
*
1248:  DECFSZ 22,W
124A:  BRA    124E
124C:  BRA    1254
....................       endereco = lcd_seg_lin; 
124E:  MOVLW  40
1250:  MOVWF  23
1252:  BRA    1256
....................    else 
....................       endereco = 0; 
1254:  CLRF   23
....................    endereco += x-1; 
1256:  MOVLW  01
1258:  SUBWF  21,W
125A:  ADDWF  23,F
....................    lcd_envia_byte(0,0x80|endereco); 
125C:  MOVF   23,W
125E:  IORLW  80
1260:  MOVWF  24
1262:  CLRF   25
1264:  MOVWF  26
1266:  RCALL  1184
1268:  RETURN 0
.................... } 
....................  
.................... void lcd_escreve( char c) 
.................... // envia caractere para o display 
.................... { 
....................    switch (c) 
126A:  MOVF   20,W
126C:  XORLW  0C
126E:  BZ    127E
1270:  XORLW  06
1272:  BZ    128E
1274:  XORLW  07
1276:  BZ    128E
1278:  XORLW  05
127A:  BZ    129A
127C:  BRA    12A4
....................    { 
....................      case '\f'    :   lcd_envia_byte(0,1); 
127E:  CLRF   25
1280:  MOVLW  01
1282:  MOVWF  26
1284:  RCALL  1184
....................               delay_ms(2); 
1286:  MOVLW  02
1288:  MOVWF  21
128A:  RCALL  1100
....................             break; 
128C:  BRA    12AE
....................      case '\n'   : 
....................      case '\r'    :   lcd_pos_xy(1,2); 
128E:  MOVLW  01
1290:  MOVWF  21
1292:  MOVLW  02
1294:  MOVWF  22
1296:  RCALL  1248
....................               break; 
1298:  BRA    12AE
....................      case '\b'    :   lcd_envia_byte(0,0x10); 
129A:  CLRF   25
129C:  MOVLW  10
129E:  MOVWF  26
12A0:  RCALL  1184
....................               break; 
12A2:  BRA    12AE
....................      default   :   lcd_envia_byte(1,c); 
12A4:  MOVLW  01
12A6:  MOVWF  25
12A8:  MOVFF  20,26
12AC:  RCALL  1184
....................               break; 
....................    } 
12AE:  RETURN 0
.................... } 
....................  
.................... char lcd_le( byte x, byte y) 
.................... // le caractere do display 
.................... { 
....................    char valor; 
....................    // seleciona a posi��o do caractere 
....................    lcd_pos_xy(x,y); 
....................    // ativa rs 
....................    output_high(lcd_rs); 
....................    // l� o caractere 
....................    valor = lcd_le_byte(); 
....................    // desativa rs 
....................    output_low(lcd_rs); 
....................    // retorna o valor do caractere 
....................    return valor; 
.................... } 
....................  
.................... void lcd_apaga() 
.................... { 
....................    lcd_envia_byte(0,1); 
....................    delay_ms(2); 
.................... } 
....................  
.................... void lcd_cursor_on() 
....................     { 
.................... lcd_envia_byte(0,0x0E); 
....................     } 
....................  
.................... void lcd_cursor_pisca() 
....................     { 
.................... lcd_envia_byte(0,0x0F); 
....................     } 
....................  
.................... void lcd_cursor_off() 
....................     { 
....................  lcd_envia_byte(0,0x0C); 
....................     } 
....................  
.................... void lcd_corre_esquerda() 
....................     { 
....................  lcd_envia_byte(0,0x18); 
....................     } 
....................  
.................... void lcd_corre_direita() 
....................     { 
.................... lcd_envia_byte(0,0x1C); 
....................     } 
....................  
....................  
....................  
.................... #define button1 pin_a4 
.................... #define button2 pin_a5 
.................... #define button3 pin_e0 
.................... #define button4 pin_e1 
....................  
.................... int running; 
.................... const char blankScreen[] = "                "; 
....................  
.................... void ClearScreen(); 
.................... void Setup(); 
.................... void IntToString(int16, char *); 
....................  
.................... #int_timer0 
.................... void timerTick() 
.................... { 
....................     //if (running) 
....................     //Codigo 
*
10C6:  BCF    FF2.2
10C8:  GOTO   1054
.................... } 
....................  
.................... void main() 
*
14CA:  CLRF   FF8
14CC:  BCF    FD0.7
14CE:  BSF    07.7
14D0:  MOVF   FC1,W
14D2:  ANDLW  C0
14D4:  IORLW  0F
14D6:  MOVWF  FC1
14D8:  MOVLW  07
14DA:  MOVWF  FB4
.................... { 
....................     Setup(); 
14DC:  BRA    121E
....................     lcd_pos_xy(1, 1); 
14DE:  MOVLW  01
14E0:  MOVWF  21
14E2:  MOVWF  22
14E4:  RCALL  1248
....................     printf(lcd_escreve, " Inicializando"); 
14E6:  MOVLW  CC
14E8:  MOVWF  FF6
14EA:  MOVLW  10
14EC:  MOVWF  FF7
14EE:  RCALL  12B0
....................     delay_ms(20); 
14F0:  MOVLW  14
14F2:  MOVWF  21
14F4:  RCALL  1100
....................     do 
....................     { 
....................         ClearScreen(); 
14F6:  BRA    12D0
....................         if (input(button1) == 0) 
14F8:  BSF    F92.4
14FA:  BTFSC  F80.4
14FC:  BRA    1502
....................         { 
....................             running = 1; 
14FE:  MOVLW  01
1500:  MOVWF  16
....................         } 
....................         if (input(button2) == 0) 
1502:  BSF    F92.5
1504:  BTFSC  F80.5
1506:  BRA    150A
....................         { 
....................             running = 0; 
1508:  CLRF   16
....................         } 
....................         lcd_pos_xy(1, 1); 
150A:  MOVLW  01
150C:  MOVWF  21
150E:  MOVWF  22
1510:  RCALL  1248
....................  
....................         int16 ad1; 
....................         set_adc_channel(1); 
1512:  MOVLW  04
1514:  MOVWF  01
1516:  MOVF   FC2,W
1518:  ANDLW  C3
151A:  IORWF  01,W
151C:  MOVWF  FC2
....................         delay_us(25); 
151E:  MOVLW  63
1520:  MOVWF  00
1522:  DECFSZ 00,F
1524:  BRA    1522
1526:  BRA    1528
....................         lcd_pos_xy(1, 2); 
1528:  MOVLW  01
152A:  MOVWF  21
152C:  MOVLW  02
152E:  MOVWF  22
1530:  RCALL  1248
....................         if (ad1 > 9306) 
1532:  MOVF   18,W
1534:  SUBLW  23
1536:  BC    154E
1538:  XORLW  FF
153A:  BNZ   1542
153C:  MOVF   17,W
153E:  SUBLW  5A
1540:  BC    154E
....................         { 
....................             printf(lcd_escreve, "Maior que 9306"); 
1542:  MOVLW  DC
1544:  MOVWF  FF6
1546:  MOVLW  10
1548:  MOVWF  FF7
154A:  RCALL  12B0
....................         } 
154C:  BRA    1558
....................         else 
....................             printf(lcd_escreve, "Menor que 9306"); 
154E:  MOVLW  EC
1550:  MOVWF  FF6
1552:  MOVLW  10
1554:  MOVWF  FF7
1556:  RCALL  12B0
....................         lcd_pos_xy(1, 1); 
1558:  MOVLW  01
155A:  MOVWF  21
155C:  MOVWF  22
155E:  RCALL  1248
....................         ad1 = read_adc(); 
1560:  BSF    FC2.1
1562:  BTFSC  FC2.1
1564:  BRA    1562
1566:  MOVFF  FC3,17
156A:  MOVFF  FC4,18
....................  
....................         char string[5]; 
....................         //intToString(counter, string); 
....................         //printf(lcd_escreve, "C:"); 
....................         //printf(lcd_escreve, string); 
....................         printf(lcd_escreve, "1: "); 
156E:  MOVLW  FC
1570:  MOVWF  FF6
1572:  MOVLW  10
1574:  MOVWF  FF7
1576:  RCALL  12B0
....................         intToString(ad1, string); 
1578:  MOVFF  18,1F
157C:  MOVFF  17,1E
1580:  CLRF   21
1582:  MOVLW  19
1584:  MOVWF  20
1586:  BRA    133C
....................         printf(lcd_escreve, string); 
1588:  CLRF   FEA
158A:  MOVLW  19
158C:  MOVWF  FE9
158E:  BRA    14A4
....................  
....................         delay_ms(100); 
1590:  MOVLW  64
1592:  MOVWF  21
1594:  RCALL  1100
....................     } while (1); 
1596:  BRA    14F6
.................... } 
....................  
1598:  SLEEP 
.................... void Setup() 
.................... { 
....................     running = 1; 
*
121E:  MOVLW  01
1220:  MOVWF  16
....................  
....................     setup_adc_ports(AN0_TO_AN3); 
1222:  MOVF   FC1,W
1224:  ANDLW  C0
1226:  IORLW  0B
1228:  MOVWF  FC1
....................     setup_adc(ADC_CLOCK_DIV_4); 
122A:  MOVF   FC0,W
122C:  ANDLW  C0
122E:  IORLW  04
1230:  MOVWF  FC0
1232:  BSF    FC0.7
1234:  BSF    FC2.0
....................  
....................     setup_timer_0(RTCC_INTERNAL | RTCC_DIV_2 | RTCC_8_BIT); 
1236:  MOVLW  C0
1238:  MOVWF  FD5
....................     set_timer0(0); 
123A:  CLRF   FD7
123C:  CLRF   FD6
....................     enable_interrupts(INT_TIMER0); 
123E:  BSF    FF2.5
....................     enable_interrupts(GLOBAL); 
1240:  IORWF  FF2,F
....................  
....................     InitializeLcd(); 
1242:  BRA    11B8
1244:  GOTO   14DE (RETURN)
.................... } 
....................  
.................... void ClearScreen() 
.................... { 
....................     lcd_pos_xy(1, 1); 
*
12D0:  MOVLW  01
12D2:  MOVWF  21
12D4:  MOVWF  22
12D6:  RCALL  1248
....................     printf(lcd_escreve, blankScreen); 
12D8:  MOVLW  B4
12DA:  MOVWF  FF6
12DC:  MOVLW  10
12DE:  MOVWF  FF7
12E0:  RCALL  12B0
....................     lcd_pos_xy(1, 2); 
12E2:  MOVLW  01
12E4:  MOVWF  21
12E6:  MOVLW  02
12E8:  MOVWF  22
12EA:  RCALL  1248
....................     printf(lcd_escreve, blankScreen); 
12EC:  MOVLW  B4
12EE:  MOVWF  FF6
12F0:  MOVLW  10
12F2:  MOVWF  FF7
12F4:  RCALL  12B0
12F6:  GOTO   14F8 (RETURN)
.................... } 
....................  
.................... void IntToString(int16 value, char *buffer) 
.................... { 
....................     buffer[0] = (value / 10000) % 10; 
*
133C:  MOVF   20,W
133E:  MOVWF  FE9
1340:  MOVFF  21,FEA
1344:  MOVFF  1F,27
1348:  MOVFF  1E,26
134C:  MOVLW  27
134E:  MOVWF  29
1350:  MOVLW  10
1352:  MOVWF  28
1354:  RCALL  12FA
1356:  MOVFF  02,25
135A:  MOVFF  01,24
135E:  MOVFF  02,27
1362:  MOVFF  01,26
1366:  CLRF   29
1368:  MOVLW  0A
136A:  MOVWF  28
136C:  RCALL  12FA
136E:  MOVFF  00,FEF
....................     buffer[1] = (value / 1000) % 10; 
1372:  MOVLW  01
1374:  ADDWF  20,W
1376:  MOVWF  FE9
1378:  MOVLW  00
137A:  ADDWFC 21,W
137C:  MOVWF  FEA
137E:  MOVFF  1F,27
1382:  MOVFF  1E,26
1386:  MOVLW  03
1388:  MOVWF  29
138A:  MOVLW  E8
138C:  MOVWF  28
138E:  RCALL  12FA
1390:  MOVFF  02,25
1394:  MOVFF  01,24
1398:  MOVFF  02,27
139C:  MOVFF  01,26
13A0:  CLRF   29
13A2:  MOVLW  0A
13A4:  MOVWF  28
13A6:  RCALL  12FA
13A8:  MOVFF  00,FEF
....................     buffer[2] = (value / 100) % 10; 
13AC:  MOVLW  02
13AE:  ADDWF  20,W
13B0:  MOVWF  FE9
13B2:  MOVLW  00
13B4:  ADDWFC 21,W
13B6:  MOVWF  FEA
13B8:  MOVFF  1F,27
13BC:  MOVFF  1E,26
13C0:  CLRF   29
13C2:  MOVLW  64
13C4:  MOVWF  28
13C6:  RCALL  12FA
13C8:  MOVFF  02,25
13CC:  MOVFF  01,24
13D0:  MOVFF  02,27
13D4:  MOVFF  01,26
13D8:  CLRF   29
13DA:  MOVLW  0A
13DC:  MOVWF  28
13DE:  RCALL  12FA
13E0:  MOVFF  00,FEF
....................     buffer[3] = (value / 10) % 10; 
13E4:  MOVLW  03
13E6:  ADDWF  20,W
13E8:  MOVWF  FE9
13EA:  MOVLW  00
13EC:  ADDWFC 21,W
13EE:  MOVWF  FEA
13F0:  MOVFF  1F,27
13F4:  MOVFF  1E,26
13F8:  CLRF   29
13FA:  MOVLW  0A
13FC:  MOVWF  28
13FE:  RCALL  12FA
1400:  MOVFF  02,25
1404:  MOVFF  01,24
1408:  MOVFF  02,27
140C:  MOVFF  01,26
1410:  CLRF   29
1412:  MOVLW  0A
1414:  MOVWF  28
1416:  RCALL  12FA
1418:  MOVFF  00,FEF
....................     buffer[4] = value % 10; 
141C:  MOVLW  04
141E:  ADDWF  20,W
1420:  MOVWF  FE9
1422:  MOVLW  00
1424:  ADDWFC 21,W
1426:  MOVWF  FEA
1428:  MOVFF  1F,27
142C:  MOVFF  1E,26
1430:  CLRF   29
1432:  MOVLW  0A
1434:  MOVWF  28
1436:  RCALL  12FA
1438:  MOVFF  00,FEF
....................  
....................     buffer[0] += 48; 
143C:  MOVFF  20,FE9
1440:  MOVFF  21,FEA
1444:  MOVLW  30
1446:  ADDWF  FEF,W
1448:  MOVWF  FEF
....................     buffer[1] += 48; 
144A:  MOVLW  01
144C:  ADDWF  20,W
144E:  MOVWF  FE9
1450:  MOVLW  00
1452:  ADDWFC 21,W
1454:  MOVWF  FEA
1456:  MOVLW  30
1458:  ADDWF  FEF,W
145A:  MOVWF  FEF
....................     buffer[2] += 48; 
145C:  MOVLW  02
145E:  ADDWF  20,W
1460:  MOVWF  FE9
1462:  MOVLW  00
1464:  ADDWFC 21,W
1466:  MOVWF  FEA
1468:  MOVLW  30
146A:  ADDWF  FEF,W
146C:  MOVWF  FEF
....................     buffer[3] += 48; 
146E:  MOVLW  03
1470:  ADDWF  20,W
1472:  MOVWF  FE9
1474:  MOVLW  00
1476:  ADDWFC 21,W
1478:  MOVWF  FEA
147A:  MOVLW  30
147C:  ADDWF  FEF,W
147E:  MOVWF  FEF
....................     buffer[4] += 48; 
1480:  MOVLW  04
1482:  ADDWF  20,W
1484:  MOVWF  FE9
1486:  MOVLW  00
1488:  ADDWFC 21,W
148A:  MOVWF  FEA
148C:  MOVLW  30
148E:  ADDWF  FEF,W
1490:  MOVWF  FEF
....................  
....................     buffer[5] = '\0'; 
1492:  MOVLW  05
1494:  ADDWF  20,W
1496:  MOVWF  FE9
1498:  MOVLW  00
149A:  ADDWFC 21,W
149C:  MOVWF  FEA
149E:  CLRF   FEF
14A0:  GOTO   1588 (RETURN)
.................... } 

Configuration Fuses:
   Word  1: CE24   PLL5 CPUDIV1 USBDIV HSPLL FCMEN IESO
   Word  2: 0E38   PUT NOBROWNOUT BORV21 VREGEN NOWDT WDT128
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
