CCS PCH C Compiler, Version 5.015, 5967               18-ago-18 02:28

               Filename:   D:\Projetos\Imposto\Source Code\main.lst

               ROM used:   1480 bytes (5%)
                           Largest free fragment is 27188
               RAM used:   30 (1%) at main() level
                           64 (3%) worst case
               Stack used: 7 locations (5 in main + 2 for interrupts)
               Stack size: 31

*
1000:  GOTO   1532
*
1008:  MOVWF  04
100A:  MOVFF  FD8,05
100E:  MOVFF  FE0,06
1012:  MOVLB  0
1014:  MOVFF  FE9,0C
1018:  MOVFF  FEA,07
101C:  MOVFF  FE1,08
1020:  MOVFF  FE2,09
1024:  MOVFF  FD9,0A
1028:  MOVFF  FDA,0B
102C:  MOVFF  FF3,12
1030:  MOVFF  FF4,13
1034:  MOVFF  FFA,14
1038:  MOVFF  00,0E
103C:  MOVFF  01,0F
1040:  MOVFF  02,10
1044:  MOVFF  03,11
1048:  BTFSS  FF2.5
104A:  GOTO   1054
104E:  BTFSC  FF2.2
1050:  GOTO   1144
1054:  MOVFF  0E,00
1058:  MOVFF  0F,01
105C:  MOVFF  10,02
1060:  MOVFF  11,03
1064:  MOVFF  0C,FE9
1068:  MOVFF  07,FEA
106C:  BSF    07.7
106E:  MOVFF  08,FE1
1072:  MOVFF  09,FE2
1076:  MOVFF  0A,FD9
107A:  MOVFF  0B,FDA
107E:  MOVFF  12,FF3
1082:  MOVFF  13,FF4
1086:  MOVFF  14,FFA
108A:  MOVF   04,W
108C:  MOVFF  06,FE0
1090:  MOVFF  05,FD8
1094:  RETFIE 0
.................... #include <main.h> 
.................... #include "18F4550.h" 
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4550 
1096:  MOVFF  FF2,0D
109A:  BCF    FF2.7
109C:  CLRF   FF7
109E:  ADDLW  B0
10A0:  MOVWF  FF6
10A2:  MOVLW  10
10A4:  ADDWFC FF7,F
10A6:  TBLRD*+
10A8:  MOVF   FF5,W
10AA:  BTFSC  0D.7
10AC:  BSF    FF2.7
10AE:  RETURN 0
10B0:  DATA 28,0C
10B2:  DATA 01,06
10B4:  BTFSC  FD8.1
10B6:  BRA    10BE
10B8:  CLRF   FEA
10BA:  MOVLW  3B
10BC:  MOVWF  FE9
10BE:  CLRF   00
10C0:  CLRF   01
10C2:  CLRF   02
10C4:  CLRF   03
10C6:  CLRF   3B
10C8:  CLRF   3C
10CA:  CLRF   3D
10CC:  CLRF   3E
10CE:  MOVF   3A,W
10D0:  IORWF  39,W
10D2:  IORWF  38,W
10D4:  IORWF  37,W
10D6:  BZ    1130
10D8:  MOVLW  20
10DA:  MOVWF  3F
10DC:  BCF    FD8.0
10DE:  RLCF   33,F
10E0:  RLCF   34,F
10E2:  RLCF   35,F
10E4:  RLCF   36,F
10E6:  RLCF   3B,F
10E8:  RLCF   3C,F
10EA:  RLCF   3D,F
10EC:  RLCF   3E,F
10EE:  MOVF   3A,W
10F0:  SUBWF  3E,W
10F2:  BNZ   1104
10F4:  MOVF   39,W
10F6:  SUBWF  3D,W
10F8:  BNZ   1104
10FA:  MOVF   38,W
10FC:  SUBWF  3C,W
10FE:  BNZ   1104
1100:  MOVF   37,W
1102:  SUBWF  3B,W
1104:  BNC   1124
1106:  MOVF   37,W
1108:  SUBWF  3B,F
110A:  MOVF   38,W
110C:  BTFSS  FD8.0
110E:  INCFSZ 38,W
1110:  SUBWF  3C,F
1112:  MOVF   39,W
1114:  BTFSS  FD8.0
1116:  INCFSZ 39,W
1118:  SUBWF  3D,F
111A:  MOVF   3A,W
111C:  BTFSS  FD8.0
111E:  INCFSZ 3A,W
1120:  SUBWF  3E,F
1122:  BSF    FD8.0
1124:  RLCF   00,F
1126:  RLCF   01,F
1128:  RLCF   02,F
112A:  RLCF   03,F
112C:  DECFSZ 3F,F
112E:  BRA    10DC
1130:  MOVFF  3B,FEF
1134:  MOVFF  3C,FEC
1138:  MOVFF  3D,FEC
113C:  MOVFF  3E,FEC
1140:  GOTO   117E (RETURN)
*
11AA:  DATA 20,49
11AC:  DATA 6E,69
11AE:  DATA 63,69
11B0:  DATA 61,6C
11B2:  DATA 69,7A
11B4:  DATA 61,6E
11B6:  DATA 64,6F
11B8:  DATA 00,00
*
1340:  TBLRD*+
1342:  MOVF   FF5,F
1344:  BZ    135E
1346:  MOVFF  FF6,22
134A:  MOVFF  FF7,23
134E:  MOVFF  FF5,24
1352:  RCALL  12FA
1354:  MOVFF  22,FF6
1358:  MOVFF  23,FF7
135C:  BRA    1340
135E:  GOTO   1574 (RETURN)
1362:  CLRF   01
1364:  CLRF   02
1366:  CLRF   00
1368:  CLRF   03
136A:  MOVF   2D,W
136C:  BNZ   1372
136E:  MOVF   2C,W
1370:  BZ    13A2
1372:  MOVLW  10
1374:  MOVWF  2E
1376:  BCF    FD8.0
1378:  RLCF   2A,F
137A:  RLCF   2B,F
137C:  RLCF   00,F
137E:  RLCF   03,F
1380:  MOVF   2D,W
1382:  SUBWF  03,W
1384:  BNZ   138A
1386:  MOVF   2C,W
1388:  SUBWF  00,W
138A:  BNC   139A
138C:  MOVF   2C,W
138E:  SUBWF  00,F
1390:  BTFSS  FD8.0
1392:  DECF   03,F
1394:  MOVF   2D,W
1396:  SUBWF  03,F
1398:  BSF    FD8.0
139A:  RLCF   01,F
139C:  RLCF   02,F
139E:  DECFSZ 2E,F
13A0:  BRA    1376
13A2:  RETURN 0
*
150C:  MOVF   FEF,F
150E:  BZ    152E
1510:  MOVFF  FEA,23
1514:  MOVFF  FE9,22
1518:  MOVFF  FEF,24
151C:  RCALL  12FA
151E:  MOVFF  23,FEA
1522:  MOVFF  22,FE9
1526:  INCF   FE9,F
1528:  BTFSC  FD8.2
152A:  INCF   FEA,F
152C:  BRA    150C
152E:  GOTO   15C2 (RETURN)
....................  
.................... #list 
....................  
.................... #device ADC=10 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES WDT128                   //Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOXINST                  //Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
....................  
.................... #use delay(clock=48MHz,crystal=20MHz) 
*
11BA:  CLRF   FEA
11BC:  MOVLW  25
11BE:  MOVWF  FE9
11C0:  MOVF   FEF,W
11C2:  BZ    11E0
11C4:  MOVLW  0F
11C6:  MOVWF  01
11C8:  CLRF   00
11CA:  DECFSZ 00,F
11CC:  BRA    11CA
11CE:  DECFSZ 01,F
11D0:  BRA    11C8
11D2:  MOVLW  8F
11D4:  MOVWF  00
11D6:  DECFSZ 00,F
11D8:  BRA    11D6
11DA:  NOP   
11DC:  DECFSZ FEF,F
11DE:  BRA    11C4
11E0:  RETURN 0
*
121C:  MOVLW  01
121E:  SUBWF  2B,F
1220:  BNC   123A
1222:  CLRF   FEA
1224:  MOVLW  2B
1226:  MOVWF  FE9
1228:  MOVF   FEF,W
122A:  BZ    123A
122C:  MOVLW  02
122E:  MOVWF  00
1230:  DECFSZ 00,F
1232:  BRA    1230
1234:  BRA    1236
1236:  DECFSZ FEF,F
1238:  BRA    122C
123A:  GOTO   1254 (RETURN)
....................  
.................... #build(reset=0x1000, interrupt=0x1008) 
.................... #org 0x000, 0xfff { } 
....................  
.................... #include <LCD_KIT.c> 
.................... /************************************************************************/ 
.................... /*  MOD_LCD.C - Biblioteca de manipula��o de m�dulo LCD                 */ 
.................... /*                                                                      */ 
.................... /*  Autor: F�bio Pereira                                                */ 
.................... /*                                                                      */ 
.................... /************************************************************************/ 
.................... /* 
.................... lcd_cursor_on()                        fun��es LCD 
.................... lcd_cursor_pisca() 
.................... lcd_cursor_off() 
.................... lcd_corre_esquerda() 
.................... lcd_corre_direita() 
.................... lcd_envia_nibble( byte dado ) 
.................... lcd_le_byte() 
.................... lcd_ini() 
.................... lcd_pos_xy( byte x, byte y) 
.................... lcd_escreve( char c)                  \f  Clear display                            //// 
....................                                             \n  Go to start of second line               //// 
....................                                   \b  Move back one position                   //// 
....................  
.................... lcd_le( byte x, byte y) 
.................... lcd_apaga() 
.................... { 
....................  
.................... */ 
.................... // As defini��es a seguir s�o utilizadas para acesso aos pinos do display 
.................... // caso o pino RW n�o seja utilizado, comente a defini��o lcd_rw 
.................... #ifndef lcd_enable 
....................    #define lcd_rs         pin_d2      // pino rs do LCD 
....................    #define lcd_enable     pin_d3      // pino enable do LCD 
....................    #define lcd_d4         pin_d4      // pino de dados d4 do LCD 
....................    #define lcd_d5         pin_d5      // pino de dados d5 do LCD 
....................    #define lcd_d6         pin_d6      // pino de dados d6 do LCD 
....................    #define lcd_d7         pin_d7   // pino de dados d7 do LCD 
.................... #endif 
....................  
.................... #define lcd_type 2           // 0=5x7, 1=5x10, 2=2 linhas 
.................... #define lcd_seg_lin 0x40    // Endere�o da segunda linha na RAM do LCD 
....................  
.................... // a constante abaixo define a seq��ncia de inicializa��o do m�dulo LCD 
.................... byte CONST INI_LCD[4] = {0x20 | (lcd_type << 2), 0xc, 1, 6}; 
....................  
.................... /*   O 0x20 eh p configurar o tipo do display e talz. 
....................    O Segundo numero configura o modo do cursor, sendo: 
....................                -> 0xf Cursor piscante 
....................                -> 0xe Cursor comum 
....................                -> 0xc Sem cursor 
....................    O terceiro (1) limpa o display 
....................    O Quarto volta com o cursor. 
.................... */ 
....................  
.................... byte lcd_le_byte() 
.................... // l� um byte do LCD (somente com pino RW) 
.................... { 
....................    byte dado; 
....................    // configura os pinos de dados como entradas 
....................    input(lcd_d4); 
....................    input(lcd_d5); 
....................    input(lcd_d6); 
....................    input(lcd_d7); 
....................    // se o pino rw for utilizado, coloca em 1 
....................    #ifdef lcd_rw 
....................       output_high(lcd_rw); 
....................    #endif 
....................    output_high(lcd_enable); // habilita display 
....................    dado = 0;   // zera a vari�vel de leitura 
....................    // l� os quatro bits mais significativos 
....................    if (input(lcd_d7)) bit_set(dado,7); 
....................    if (input(lcd_d6)) bit_set(dado,6); 
....................    if (input(lcd_d5)) bit_set(dado,5); 
....................    if (input(lcd_d4)) bit_set(dado,4); 
....................    // d� um pulso na linha enable 
....................    output_low(lcd_enable); 
....................    output_high(lcd_enable); 
....................    // l� os quatro bits menos significativos 
....................    if (input(lcd_d7)) bit_set(dado,3); 
....................    if (input(lcd_d6)) bit_set(dado,2); 
....................    if (input(lcd_d5)) bit_set(dado,1); 
....................    if (input(lcd_d4)) bit_set(dado,0); 
....................    output_low(lcd_enable);   // desabilita o display 
....................    return dado;   // retorna o byte lido 
.................... } 
....................  
.................... void lcd_envia_nibble( byte dado ) 
.................... // envia um dado de quatro bits para o display 
.................... { 
....................    // coloca os quatro bits nas saidas 
....................    output_bit(lcd_d4,bit_test(dado,0)); 
*
11E2:  BTFSC  2C.0
11E4:  BRA    11EA
11E6:  BCF    F8C.4
11E8:  BRA    11EC
11EA:  BSF    F8C.4
11EC:  BCF    F95.4
....................    output_bit(lcd_d5,bit_test(dado,1)); 
11EE:  BTFSC  2C.1
11F0:  BRA    11F6
11F2:  BCF    F8C.5
11F4:  BRA    11F8
11F6:  BSF    F8C.5
11F8:  BCF    F95.5
....................    output_bit(lcd_d6,bit_test(dado,2)); 
11FA:  BTFSC  2C.2
11FC:  BRA    1202
11FE:  BCF    F8C.6
1200:  BRA    1204
1202:  BSF    F8C.6
1204:  BCF    F95.6
....................    output_bit(lcd_d7,bit_test(dado,3)); 
1206:  BTFSC  2C.3
1208:  BRA    120E
120A:  BCF    F8C.7
120C:  BRA    1210
120E:  BSF    F8C.7
1210:  BCF    F95.7
....................    // d� um pulso na linha enable 
....................    output_high(lcd_enable); 
1212:  BCF    F95.3
1214:  BSF    F8C.3
....................    output_low(lcd_enable); 
1216:  BCF    F95.3
1218:  BCF    F8C.3
121A:  RETURN 0
.................... } 
....................  
....................  
.................... void lcd_envia_byte( boolean endereco, byte dado ) 
.................... { 
....................    // coloca a linha rs em 0 
....................    output_low(lcd_rs); 
*
123E:  BCF    F95.2
1240:  BCF    F8C.2
....................    // aguarda o display ficar desocupado 
....................    //while ( bit_test(lcd_le_byte(),7) ) ; 
....................    // configura a linha rs dependendo do modo selecionado 
....................    output_bit(lcd_rs,endereco); 
1242:  MOVF   29,F
1244:  BNZ   124A
1246:  BCF    F8C.2
1248:  BRA    124C
124A:  BSF    F8C.2
124C:  BCF    F95.2
....................    delay_us(100);   // aguarda 100 us 
124E:  MOVLW  64
1250:  MOVWF  2B
1252:  BRA    121C
....................    // caso a linha rw esteja definida, coloca em 0 
....................    #ifdef lcd_rw 
....................       output_low(lcd_rw); 
....................    #endif 
....................    // desativa linha enable 
....................    output_low(lcd_enable); 
1254:  BCF    F95.3
1256:  BCF    F8C.3
....................    // envia a primeira parte do byte 
....................    lcd_envia_nibble(dado >> 4); 
1258:  SWAPF  2A,W
125A:  MOVWF  2B
125C:  MOVLW  0F
125E:  ANDWF  2B,F
1260:  MOVFF  2B,2C
1264:  RCALL  11E2
....................    // envia a segunda parte do byte 
....................    lcd_envia_nibble(dado & 0x0f); 
1266:  MOVF   2A,W
1268:  ANDLW  0F
126A:  MOVWF  2B
126C:  MOVWF  2C
126E:  RCALL  11E2
1270:  RETURN 0
.................... } 
....................  
....................  
.................... void InitializeLcd() 
.................... // rotina de inicializa��o do display 
.................... { 
....................    byte conta; 
....................    output_low(lcd_d4); 
1272:  BCF    F95.4
1274:  BCF    F8C.4
....................    output_low(lcd_d5); 
1276:  BCF    F95.5
1278:  BCF    F8C.5
....................    output_low(lcd_d6); 
127A:  BCF    F95.6
127C:  BCF    F8C.6
....................    output_low(lcd_d7); 
127E:  BCF    F95.7
1280:  BCF    F8C.7
....................    output_low(lcd_rs); 
1282:  BCF    F95.2
1284:  BCF    F8C.2
....................    #ifdef lcd_rw 
....................       output_high(lcd_rw); 
....................    #endif 
....................    output_low(lcd_enable); 
1286:  BCF    F95.3
1288:  BCF    F8C.3
....................    delay_ms(15); 
128A:  MOVLW  0F
128C:  MOVWF  25
128E:  RCALL  11BA
....................    // envia uma seq��ncia de 3 vezes 0x03 
....................    // e depois 0x02 para configurar o m�dulo 
....................    // para modo de 4 bits 
....................    for(conta=1;conta<=3;++conta) 
1290:  MOVLW  01
1292:  MOVWF  22
1294:  MOVF   22,W
1296:  SUBLW  03
1298:  BNC   12AA
....................    { 
....................       lcd_envia_nibble(3); 
129A:  MOVLW  03
129C:  MOVWF  2C
129E:  RCALL  11E2
....................       delay_ms(5); 
12A0:  MOVLW  05
12A2:  MOVWF  25
12A4:  RCALL  11BA
12A6:  INCF   22,F
12A8:  BRA    1294
....................    } 
....................    lcd_envia_nibble(2); 
12AA:  MOVLW  02
12AC:  MOVWF  2C
12AE:  RCALL  11E2
....................    // envia string de inicializa��o do display 
....................    for(conta=0;conta<=3;++conta) lcd_envia_byte(0,INI_LCD[conta]); 
12B0:  CLRF   22
12B2:  MOVF   22,W
12B4:  SUBLW  03
12B6:  BNC   12D4
12B8:  CLRF   03
12BA:  MOVF   22,W
12BC:  MOVFF  FF2,23
12C0:  BCF    FF2.7
12C2:  RCALL  1096
12C4:  BTFSC  23.7
12C6:  BSF    FF2.7
12C8:  MOVWF  23
12CA:  CLRF   29
12CC:  MOVWF  2A
12CE:  RCALL  123E
12D0:  INCF   22,F
12D2:  BRA    12B2
12D4:  GOTO   1562 (RETURN)
.................... } 
....................  
.................... void lcd_pos_xy( byte x, byte y) 
.................... { 
....................    byte endereco; 
....................    if(y!=1) 
12D8:  DECFSZ 26,W
12DA:  BRA    12DE
12DC:  BRA    12E4
....................       endereco = lcd_seg_lin; 
12DE:  MOVLW  40
12E0:  MOVWF  27
12E2:  BRA    12E6
....................    else 
....................       endereco = 0; 
12E4:  CLRF   27
....................    endereco += x-1; 
12E6:  MOVLW  01
12E8:  SUBWF  25,W
12EA:  ADDWF  27,F
....................    lcd_envia_byte(0,0x80|endereco); 
12EC:  MOVF   27,W
12EE:  IORLW  80
12F0:  MOVWF  28
12F2:  CLRF   29
12F4:  MOVWF  2A
12F6:  RCALL  123E
12F8:  RETURN 0
.................... } 
....................  
.................... void lcd_escreve( char c) 
.................... // envia caractere para o display 
.................... { 
....................    switch (c) 
12FA:  MOVF   24,W
12FC:  XORLW  0C
12FE:  BZ    130E
1300:  XORLW  06
1302:  BZ    131E
1304:  XORLW  07
1306:  BZ    131E
1308:  XORLW  05
130A:  BZ    132A
130C:  BRA    1334
....................    { 
....................      case '\f'    :   lcd_envia_byte(0,1); 
130E:  CLRF   29
1310:  MOVLW  01
1312:  MOVWF  2A
1314:  RCALL  123E
....................               delay_ms(2); 
1316:  MOVLW  02
1318:  MOVWF  25
131A:  RCALL  11BA
....................             break; 
131C:  BRA    133E
....................      case '\n'   : 
....................      case '\r'    :   lcd_pos_xy(1,2); 
131E:  MOVLW  01
1320:  MOVWF  25
1322:  MOVLW  02
1324:  MOVWF  26
1326:  RCALL  12D8
....................               break; 
1328:  BRA    133E
....................      case '\b'    :   lcd_envia_byte(0,0x10); 
132A:  CLRF   29
132C:  MOVLW  10
132E:  MOVWF  2A
1330:  RCALL  123E
....................               break; 
1332:  BRA    133E
....................      default   :   lcd_envia_byte(1,c); 
1334:  MOVLW  01
1336:  MOVWF  29
1338:  MOVFF  24,2A
133C:  RCALL  123E
....................               break; 
....................    } 
133E:  RETURN 0
.................... } 
....................  
.................... char lcd_le( byte x, byte y) 
.................... // le caractere do display 
.................... { 
....................    char valor; 
....................    // seleciona a posi��o do caractere 
....................    lcd_pos_xy(x,y); 
....................    // ativa rs 
....................    output_high(lcd_rs); 
....................    // l� o caractere 
....................    valor = lcd_le_byte(); 
....................    // desativa rs 
....................    output_low(lcd_rs); 
....................    // retorna o valor do caractere 
....................    return valor; 
.................... } 
....................  
.................... void lcd_apaga() 
.................... { 
....................    lcd_envia_byte(0,1); 
....................    delay_ms(2); 
.................... } 
....................  
.................... void lcd_cursor_on() 
....................     { 
.................... lcd_envia_byte(0,0x0E); 
....................     } 
....................  
.................... void lcd_cursor_pisca() 
....................     { 
.................... lcd_envia_byte(0,0x0F); 
....................     } 
....................  
.................... void lcd_cursor_off() 
....................     { 
....................  lcd_envia_byte(0,0x0C); 
....................     } 
....................  
.................... void lcd_corre_esquerda() 
....................     { 
....................  lcd_envia_byte(0,0x18); 
....................     } 
....................  
.................... void lcd_corre_direita() 
....................     { 
.................... lcd_envia_byte(0,0x1C); 
....................     } 
....................  
....................  
....................  
.................... #define button1 pin_a4 
.................... #define button2 pin_a5 
.................... #define button3 pin_e0 
.................... #define button4 pin_e1 
....................  
.................... int16 counter; 
.................... int32 hideCounter; 
.................... int running; 
....................  
.................... #int_timer0 
.................... void timerTick() 
.................... { 
....................     if (running) 
*
1144:  MOVF   1C,F
1146:  BZ    1158
....................         hideCounter++; 
1148:  MOVLW  01
114A:  ADDWF  18,F
114C:  BTFSC  FD8.0
114E:  INCF   19,F
1150:  BTFSC  FD8.2
1152:  INCF   1A,F
1154:  BTFSC  FD8.2
1156:  INCF   1B,F
....................     if (hideCounter % 1000 == 0) 
1158:  BSF    FD8.1
115A:  CLRF   FEA
115C:  MOVLW  2F
115E:  MOVWF  FE9
1160:  MOVFF  1B,36
1164:  MOVFF  1A,35
1168:  MOVFF  19,34
116C:  MOVFF  18,33
1170:  CLRF   3A
1172:  CLRF   39
1174:  MOVLW  03
1176:  MOVWF  38
1178:  MOVLW  E8
117A:  MOVWF  37
117C:  BRA    10B4
117E:  MOVFF  32,36
1182:  MOVFF  31,35
1186:  MOVFF  30,34
118A:  MOVFF  2F,33
118E:  MOVF   33,F
1190:  BNZ   11A4
1192:  MOVF   34,F
1194:  BNZ   11A4
1196:  MOVF   35,F
1198:  BNZ   11A4
119A:  MOVF   36,F
119C:  BNZ   11A4
....................     { 
....................         counter++; 
119E:  INCF   16,F
11A0:  BTFSC  FD8.2
11A2:  INCF   17,F
....................     } 
11A4:  BCF    FF2.2
11A6:  GOTO   1054
.................... } 
....................  
.................... void intToString(int16 value, char *buffer) 
.................... { 
....................  
....................     buffer[0] = (value / 10000) % 10; 
*
13A4:  MOVF   24,W
13A6:  MOVWF  FE9
13A8:  MOVFF  25,FEA
13AC:  MOVFF  23,2B
13B0:  MOVFF  22,2A
13B4:  MOVLW  27
13B6:  MOVWF  2D
13B8:  MOVLW  10
13BA:  MOVWF  2C
13BC:  RCALL  1362
13BE:  MOVFF  02,29
13C2:  MOVFF  01,28
13C6:  MOVFF  02,2B
13CA:  MOVFF  01,2A
13CE:  CLRF   2D
13D0:  MOVLW  0A
13D2:  MOVWF  2C
13D4:  RCALL  1362
13D6:  MOVFF  00,FEF
....................     buffer[1] = (value / 1000) % 10; 
13DA:  MOVLW  01
13DC:  ADDWF  24,W
13DE:  MOVWF  FE9
13E0:  MOVLW  00
13E2:  ADDWFC 25,W
13E4:  MOVWF  FEA
13E6:  MOVFF  23,2B
13EA:  MOVFF  22,2A
13EE:  MOVLW  03
13F0:  MOVWF  2D
13F2:  MOVLW  E8
13F4:  MOVWF  2C
13F6:  RCALL  1362
13F8:  MOVFF  02,29
13FC:  MOVFF  01,28
1400:  MOVFF  02,2B
1404:  MOVFF  01,2A
1408:  CLRF   2D
140A:  MOVLW  0A
140C:  MOVWF  2C
140E:  RCALL  1362
1410:  MOVFF  00,FEF
....................     buffer[2] = (value / 100) % 10; 
1414:  MOVLW  02
1416:  ADDWF  24,W
1418:  MOVWF  FE9
141A:  MOVLW  00
141C:  ADDWFC 25,W
141E:  MOVWF  FEA
1420:  MOVFF  23,2B
1424:  MOVFF  22,2A
1428:  CLRF   2D
142A:  MOVLW  64
142C:  MOVWF  2C
142E:  RCALL  1362
1430:  MOVFF  02,29
1434:  MOVFF  01,28
1438:  MOVFF  02,2B
143C:  MOVFF  01,2A
1440:  CLRF   2D
1442:  MOVLW  0A
1444:  MOVWF  2C
1446:  RCALL  1362
1448:  MOVFF  00,FEF
....................     buffer[3] = (value / 10) % 10; 
144C:  MOVLW  03
144E:  ADDWF  24,W
1450:  MOVWF  FE9
1452:  MOVLW  00
1454:  ADDWFC 25,W
1456:  MOVWF  FEA
1458:  MOVFF  23,2B
145C:  MOVFF  22,2A
1460:  CLRF   2D
1462:  MOVLW  0A
1464:  MOVWF  2C
1466:  RCALL  1362
1468:  MOVFF  02,29
146C:  MOVFF  01,28
1470:  MOVFF  02,2B
1474:  MOVFF  01,2A
1478:  CLRF   2D
147A:  MOVLW  0A
147C:  MOVWF  2C
147E:  RCALL  1362
1480:  MOVFF  00,FEF
....................     buffer[4] = value % 10; 
1484:  MOVLW  04
1486:  ADDWF  24,W
1488:  MOVWF  FE9
148A:  MOVLW  00
148C:  ADDWFC 25,W
148E:  MOVWF  FEA
1490:  MOVFF  23,2B
1494:  MOVFF  22,2A
1498:  CLRF   2D
149A:  MOVLW  0A
149C:  MOVWF  2C
149E:  RCALL  1362
14A0:  MOVFF  00,FEF
....................  
....................     buffer[0] += 48; 
14A4:  MOVFF  24,FE9
14A8:  MOVFF  25,FEA
14AC:  MOVLW  30
14AE:  ADDWF  FEF,W
14B0:  MOVWF  FEF
....................     buffer[1] += 48; 
14B2:  MOVLW  01
14B4:  ADDWF  24,W
14B6:  MOVWF  FE9
14B8:  MOVLW  00
14BA:  ADDWFC 25,W
14BC:  MOVWF  FEA
14BE:  MOVLW  30
14C0:  ADDWF  FEF,W
14C2:  MOVWF  FEF
....................     buffer[2] += 48; 
14C4:  MOVLW  02
14C6:  ADDWF  24,W
14C8:  MOVWF  FE9
14CA:  MOVLW  00
14CC:  ADDWFC 25,W
14CE:  MOVWF  FEA
14D0:  MOVLW  30
14D2:  ADDWF  FEF,W
14D4:  MOVWF  FEF
....................     buffer[3] += 48; 
14D6:  MOVLW  03
14D8:  ADDWF  24,W
14DA:  MOVWF  FE9
14DC:  MOVLW  00
14DE:  ADDWFC 25,W
14E0:  MOVWF  FEA
14E2:  MOVLW  30
14E4:  ADDWF  FEF,W
14E6:  MOVWF  FEF
....................     buffer[4] += 48; 
14E8:  MOVLW  04
14EA:  ADDWF  24,W
14EC:  MOVWF  FE9
14EE:  MOVLW  00
14F0:  ADDWFC 25,W
14F2:  MOVWF  FEA
14F4:  MOVLW  30
14F6:  ADDWF  FEF,W
14F8:  MOVWF  FEF
....................  
....................     buffer[5] = 0; 
14FA:  MOVLW  05
14FC:  ADDWF  24,W
14FE:  MOVWF  FE9
1500:  MOVLW  00
1502:  ADDWFC 25,W
1504:  MOVWF  FEA
1506:  CLRF   FEF
1508:  GOTO   15BA (RETURN)
.................... } 
....................  
.................... void main() 
*
1532:  CLRF   FF8
1534:  BCF    FD0.7
1536:  BSF    07.7
1538:  MOVF   FC1,W
153A:  ANDLW  C0
153C:  IORLW  0F
153E:  MOVWF  FC1
1540:  MOVLW  07
1542:  MOVWF  FB4
.................... { 
....................     counter = 0; 
1544:  CLRF   17
1546:  CLRF   16
....................     hideCounter = 0; 
1548:  CLRF   1B
154A:  CLRF   1A
154C:  CLRF   19
154E:  CLRF   18
....................     running = 1; 
1550:  MOVLW  01
1552:  MOVWF  1C
....................  
....................     setup_timer_0(RTCC_INTERNAL | RTCC_DIV_2 | RTCC_8_BIT); 
1554:  MOVLW  C0
1556:  MOVWF  FD5
....................     set_timer0(0); 
1558:  CLRF   FD7
155A:  CLRF   FD6
....................     enable_interrupts(INT_TIMER0); 
155C:  BSF    FF2.5
....................     enable_interrupts(GLOBAL); 
155E:  IORWF  FF2,F
....................  
....................     InitializeLcd(); 
1560:  BRA    1272
....................     lcd_pos_xy(1, 1); 
1562:  MOVLW  01
1564:  MOVWF  25
1566:  MOVWF  26
1568:  RCALL  12D8
....................     printf(lcd_escreve, " Inicializando"); 
156A:  MOVLW  AA
156C:  MOVWF  FF6
156E:  MOVLW  11
1570:  MOVWF  FF7
1572:  BRA    1340
....................     delay_ms(20); 
1574:  MOVLW  14
1576:  MOVWF  25
1578:  RCALL  11BA
....................     do 
....................     { 
....................         lcd_pos_xy(1, 1); 
157A:  MOVLW  01
157C:  MOVWF  25
157E:  MOVWF  26
1580:  RCALL  12D8
....................         if (input(button1) == 0) 
1582:  BSF    F92.4
1584:  BTFSC  F80.4
1586:  BRA    158C
....................         { 
....................             running = 1; 
1588:  MOVLW  01
158A:  MOVWF  1C
....................         } 
....................         if (input(button2) == 0) 
158C:  BSF    F92.5
158E:  BTFSC  F80.5
1590:  BRA    1594
....................         { 
....................             running = 0; 
1592:  CLRF   1C
....................         } 
....................         lcd_pos_xy(1, 2); 
1594:  MOVLW  01
1596:  MOVWF  25
1598:  MOVLW  02
159A:  MOVWF  26
159C:  RCALL  12D8
....................         printf(lcd_escreve, "C:"); 
159E:  MOVLW  43
15A0:  MOVWF  24
15A2:  RCALL  12FA
15A4:  MOVLW  3A
15A6:  MOVWF  24
15A8:  RCALL  12FA
....................  
....................         char string[5]; 
....................         intToString(counter, string); 
15AA:  MOVFF  17,23
15AE:  MOVFF  16,22
15B2:  CLRF   25
15B4:  MOVLW  1D
15B6:  MOVWF  24
15B8:  BRA    13A4
....................  
....................         printf(lcd_escreve, string); 
15BA:  CLRF   FEA
15BC:  MOVLW  1D
15BE:  MOVWF  FE9
15C0:  BRA    150C
....................         delay_ms(100); 
15C2:  MOVLW  64
15C4:  MOVWF  25
15C6:  RCALL  11BA
....................     } while (1); 
15C8:  BRA    157A
.................... } 
15CA:  SLEEP 

Configuration Fuses:
   Word  1: CE24   PLL5 CPUDIV1 USBDIV HSPLL FCMEN IESO
   Word  2: 0E38   PUT NOBROWNOUT BORV21 VREGEN NOWDT WDT128
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
