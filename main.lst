CCS PCH C Compiler, Version 5.015, 5967               02-ago-18 21:54

               Filename:   C:\Users\Administrador\Music\Fred\Robo\ImpostoV1.2\main.lst

               ROM used:   546 bytes (2%)
                           Largest free fragment is 28122
               RAM used:   5 (0%) at main() level
                           15 (1%) worst case
               Stack used: 5 locations
               Stack size: 31

*
1000:  GOTO   11E8
.................... #include <main.h> 
.................... #include <18F4550.h> 
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4550 
*
1008:  CLRF   FF7
100A:  ADDLW  18
100C:  MOVWF  FF6
100E:  MOVLW  10
1010:  ADDWFC FF7,F
1012:  TBLRD*+
1014:  MOVF   FF5,W
1016:  RETURN 0
1018:  DATA 28,0C
101A:  DATA 01,06
101C:  DATA 0C,49
101E:  DATA 6D,70
1020:  DATA 6F,73
1022:  DATA 74,6F
1024:  DATA 20,56
1026:  DATA 31,2E
1028:  DATA 32,00
102A:  DATA 0C,31
102C:  DATA 2E,20
102E:  DATA 4C,69
1030:  DATA 6E,68
1032:  DATA 61,73
1034:  DATA 0A,32
1036:  DATA 2E,20
1038:  DATA 53,6F
103A:  DATA 6E,61
103C:  DATA 72,00
*
11C8:  TBLRD*+
11CA:  MOVF   FF5,F
11CC:  BZ    11E6
11CE:  MOVFF  FF6,05
11D2:  MOVFF  FF7,06
11D6:  MOVFF  FF5,07
11DA:  BRA    1180
11DC:  MOVFF  05,FF6
11E0:  MOVFF  06,FF7
11E4:  BRA    11C8
11E6:  RETURN 0
....................  
.................... #list 
....................  
.................... #device ADC=10 
....................  
.................... #FUSES NOWDT                 	//No Watch Dog Timer 
.................... #FUSES WDT128                	//Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES NOBROWNOUT            	//No brownout reset 
.................... #FUSES NOLVP                 	//No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOXINST               	//Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
....................  
.................... #use delay(clock=48MHz,crystal=20MHz) 
*
103E:  CLRF   FEA
1040:  MOVLW  08
1042:  MOVWF  FE9
1044:  MOVF   FEF,W
1046:  BZ    1064
1048:  MOVLW  0F
104A:  MOVWF  01
104C:  CLRF   00
104E:  DECFSZ 00,F
1050:  BRA    104E
1052:  DECFSZ 01,F
1054:  BRA    104C
1056:  MOVLW  8F
1058:  MOVWF  00
105A:  DECFSZ 00,F
105C:  BRA    105A
105E:  NOP   
1060:  DECFSZ FEF,F
1062:  BRA    1048
1064:  RETURN 0
*
10A0:  MOVLW  01
10A2:  SUBWF  0E,F
10A4:  BNC   10BE
10A6:  CLRF   FEA
10A8:  MOVLW  0E
10AA:  MOVWF  FE9
10AC:  MOVF   FEF,W
10AE:  BZ    10BE
10B0:  MOVLW  02
10B2:  MOVWF  00
10B4:  DECFSZ 00,F
10B6:  BRA    10B4
10B8:  BRA    10BA
10BA:  DECFSZ FEF,F
10BC:  BRA    10B0
10BE:  GOTO   10D8 (RETURN)
....................  
.................... #build(reset=0x1000, interrupt=0x1008) 
.................... #org 0x000, 0xfff { } 
....................  
.................... //#include <Motor1.c> 
.................... #include <lcd_kit.c> 
.................... /************************************************************************/ 
.................... /*  MOD_LCD.C - Biblioteca de manipulação de módulo LCD                 */ 
.................... /*                                                                      */ 
.................... /*  Autor: Fábio Pereira                                                */ 
.................... /*                                                                      */ 
.................... /************************************************************************/ 
.................... /* 
.................... lcd_cursor_on()                        funções LCD 
.................... lcd_cursor_pisca() 
.................... lcd_cursor_off() 
.................... lcd_corre_esquerda() 
.................... lcd_corre_direita() 
.................... lcd_envia_nibble( byte dado ) 
.................... lcd_le_byte() 
.................... lcd_ini() 
.................... lcd_pos_xy( byte x, byte y) 
.................... lcd_escreve( char c)                  \f  Clear display                            //// 
....................                                             \n  Go to start of second line               //// 
....................                                   \b  Move back one position                   //// 
....................  
.................... lcd_le( byte x, byte y) 
.................... lcd_apaga() 
.................... { 
....................  
.................... */ 
.................... // As definições a seguir são utilizadas para acesso aos pinos do display 
.................... // caso o pino RW não seja utilizado, comente a definição lcd_rw 
.................... #ifndef lcd_enable 
....................    #define lcd_rs         pin_d2      // pino rs do LCD 
....................    #define lcd_enable     pin_d3      // pino enable do LCD 
....................    #define lcd_d4         pin_d4      // pino de dados d4 do LCD 
....................    #define lcd_d5         pin_d5      // pino de dados d5 do LCD 
....................    #define lcd_d6         pin_d6      // pino de dados d6 do LCD 
....................    #define lcd_d7         pin_d7   // pino de dados d7 do LCD 
.................... #endif 
....................  
.................... #define lcd_type 2           // 0=5x7, 1=5x10, 2=2 linhas 
.................... #define lcd_seg_lin 0x40    // Endereço da segunda linha na RAM do LCD 
....................  
.................... // a constante abaixo define a seqüência de inicialização do módulo LCD 
.................... byte CONST INI_LCD[4] = {0x20 | (lcd_type << 2), 0xc, 1, 6}; 
....................  
.................... /*   O 0x20 eh p configurar o tipo do display e talz. 
....................    O Segundo numero configura o modo do cursor, sendo: 
....................                -> 0xf Cursor piscante 
....................                -> 0xe Cursor comum 
....................                -> 0xc Sem cursor 
....................    O terceiro (1) limpa o display 
....................    O Quarto volta com o cursor. 
.................... */ 
....................  
.................... byte lcd_le_byte() 
.................... // lê um byte do LCD (somente com pino RW) 
.................... { 
....................    byte dado; 
....................    // configura os pinos de dados como entradas 
....................    input(lcd_d4); 
....................    input(lcd_d5); 
....................    input(lcd_d6); 
....................    input(lcd_d7); 
....................    // se o pino rw for utilizado, coloca em 1 
....................    #ifdef lcd_rw 
....................       output_high(lcd_rw); 
....................    #endif 
....................    output_high(lcd_enable); // habilita display 
....................    dado = 0;   // zera a variável de leitura 
....................    // lê os quatro bits mais significativos 
....................    if (input(lcd_d7)) bit_set(dado,7); 
....................    if (input(lcd_d6)) bit_set(dado,6); 
....................    if (input(lcd_d5)) bit_set(dado,5); 
....................    if (input(lcd_d4)) bit_set(dado,4); 
....................    // dá um pulso na linha enable 
....................    output_low(lcd_enable); 
....................    output_high(lcd_enable); 
....................    // lê os quatro bits menos significativos 
....................    if (input(lcd_d7)) bit_set(dado,3); 
....................    if (input(lcd_d6)) bit_set(dado,2); 
....................    if (input(lcd_d5)) bit_set(dado,1); 
....................    if (input(lcd_d4)) bit_set(dado,0); 
....................    output_low(lcd_enable);   // desabilita o display 
....................    return dado;   // retorna o byte lido 
.................... } 
....................  
.................... void lcd_envia_nibble( byte dado ) 
.................... // envia um dado de quatro bits para o display 
.................... { 
....................    // coloca os quatro bits nas saidas 
....................    output_bit(lcd_d4,bit_test(dado,0)); 
*
1066:  BTFSC  0F.0
1068:  BRA    106E
106A:  BCF    F8C.4
106C:  BRA    1070
106E:  BSF    F8C.4
1070:  BCF    F95.4
....................    output_bit(lcd_d5,bit_test(dado,1)); 
1072:  BTFSC  0F.1
1074:  BRA    107A
1076:  BCF    F8C.5
1078:  BRA    107C
107A:  BSF    F8C.5
107C:  BCF    F95.5
....................    output_bit(lcd_d6,bit_test(dado,2)); 
107E:  BTFSC  0F.2
1080:  BRA    1086
1082:  BCF    F8C.6
1084:  BRA    1088
1086:  BSF    F8C.6
1088:  BCF    F95.6
....................    output_bit(lcd_d7,bit_test(dado,3)); 
108A:  BTFSC  0F.3
108C:  BRA    1092
108E:  BCF    F8C.7
1090:  BRA    1094
1092:  BSF    F8C.7
1094:  BCF    F95.7
....................    // dá um pulso na linha enable 
....................    output_high(lcd_enable); 
1096:  BCF    F95.3
1098:  BSF    F8C.3
....................    output_low(lcd_enable); 
109A:  BCF    F95.3
109C:  BCF    F8C.3
109E:  RETURN 0
.................... } 
....................  
....................  
.................... void lcd_envia_byte( boolean endereco, byte dado ) 
.................... { 
....................    // coloca a linha rs em 0 
....................    output_low(lcd_rs); 
*
10C2:  BCF    F95.2
10C4:  BCF    F8C.2
....................    // aguarda o display ficar desocupado 
....................    //while ( bit_test(lcd_le_byte(),7) ) ; 
....................    // configura a linha rs dependendo do modo selecionado 
....................    output_bit(lcd_rs,endereco); 
10C6:  MOVF   0C,F
10C8:  BNZ   10CE
10CA:  BCF    F8C.2
10CC:  BRA    10D0
10CE:  BSF    F8C.2
10D0:  BCF    F95.2
....................    delay_us(100);   // aguarda 100 us 
10D2:  MOVLW  64
10D4:  MOVWF  0E
10D6:  BRA    10A0
....................    // caso a linha rw esteja definida, coloca em 0 
....................    #ifdef lcd_rw 
....................       output_low(lcd_rw); 
....................    #endif 
....................    // desativa linha enable 
....................    output_low(lcd_enable); 
10D8:  BCF    F95.3
10DA:  BCF    F8C.3
....................    // envia a primeira parte do byte 
....................    lcd_envia_nibble(dado >> 4); 
10DC:  SWAPF  0D,W
10DE:  MOVWF  0E
10E0:  MOVLW  0F
10E2:  ANDWF  0E,F
10E4:  MOVFF  0E,0F
10E8:  RCALL  1066
....................    // envia a segunda parte do byte 
....................    lcd_envia_nibble(dado & 0x0f); 
10EA:  MOVF   0D,W
10EC:  ANDLW  0F
10EE:  MOVWF  0E
10F0:  MOVWF  0F
10F2:  RCALL  1066
10F4:  RETURN 0
.................... } 
....................  
....................  
.................... void lcd_ini() 
.................... // rotina de inicialização do display 
.................... { 
....................    byte conta; 
....................    output_low(lcd_d4); 
10F6:  BCF    F95.4
10F8:  BCF    F8C.4
....................    output_low(lcd_d5); 
10FA:  BCF    F95.5
10FC:  BCF    F8C.5
....................    output_low(lcd_d6); 
10FE:  BCF    F95.6
1100:  BCF    F8C.6
....................    output_low(lcd_d7); 
1102:  BCF    F95.7
1104:  BCF    F8C.7
....................    output_low(lcd_rs); 
1106:  BCF    F95.2
1108:  BCF    F8C.2
....................    #ifdef lcd_rw 
....................       output_high(lcd_rw); 
....................    #endif 
....................    output_low(lcd_enable); 
110A:  BCF    F95.3
110C:  BCF    F8C.3
....................    delay_ms(15); 
110E:  MOVLW  0F
1110:  MOVWF  08
1112:  RCALL  103E
....................    // envia uma seqüência de 3 vezes 0x03 
....................    // e depois 0x02 para configurar o módulo 
....................    // para modo de 4 bits 
....................    for(conta=1;conta<=3;++conta) 
1114:  MOVLW  01
1116:  MOVWF  05
1118:  MOVF   05,W
111A:  SUBLW  03
111C:  BNC   112E
....................    { 
....................       lcd_envia_nibble(3); 
111E:  MOVLW  03
1120:  MOVWF  0F
1122:  RCALL  1066
....................       delay_ms(5); 
1124:  MOVLW  05
1126:  MOVWF  08
1128:  RCALL  103E
112A:  INCF   05,F
112C:  BRA    1118
....................    } 
....................    lcd_envia_nibble(2); 
112E:  MOVLW  02
1130:  MOVWF  0F
1132:  RCALL  1066
....................    // envia string de inicialização do display 
....................    for(conta=0;conta<=3;++conta) lcd_envia_byte(0,INI_LCD[conta]); 
1134:  CLRF   05
1136:  MOVF   05,W
1138:  SUBLW  03
113A:  BNC   1158
113C:  CLRF   03
113E:  MOVF   05,W
1140:  MOVFF  FF2,06
1144:  BCF    FF2.7
1146:  RCALL  1008
1148:  BTFSC  06.7
114A:  BSF    FF2.7
114C:  MOVWF  06
114E:  CLRF   0C
1150:  MOVWF  0D
1152:  RCALL  10C2
1154:  INCF   05,F
1156:  BRA    1136
1158:  GOTO   11FA (RETURN)
.................... } 
....................  
.................... void lcd_pos_xy( byte x, byte y) 
.................... { 
....................    byte endereco; 
....................    if(y!=1) 
115C:  DECFSZ 09,W
115E:  BRA    1162
1160:  BRA    1168
....................       endereco = lcd_seg_lin; 
1162:  MOVLW  40
1164:  MOVWF  0A
1166:  BRA    116A
....................    else 
....................       endereco = 0; 
1168:  CLRF   0A
....................    endereco += x-1; 
116A:  MOVLW  01
116C:  SUBWF  08,W
116E:  ADDWF  0A,F
....................    lcd_envia_byte(0,0x80|endereco); 
1170:  MOVF   0A,W
1172:  IORLW  80
1174:  MOVWF  0B
1176:  CLRF   0C
1178:  MOVWF  0D
117A:  RCALL  10C2
117C:  GOTO   11C4 (RETURN)
.................... } 
....................  
.................... void lcd_escreve( char c) 
.................... // envia caractere para o display 
.................... { 
....................    switch (c) 
1180:  MOVF   07,W
1182:  XORLW  0C
1184:  BZ    1194
1186:  XORLW  06
1188:  BZ    11A4
118A:  XORLW  07
118C:  BZ    11A4
118E:  XORLW  05
1190:  BZ    11B0
1192:  BRA    11BA
....................    { 
....................      case '\f'    :   lcd_envia_byte(0,1); 
1194:  CLRF   0C
1196:  MOVLW  01
1198:  MOVWF  0D
119A:  RCALL  10C2
....................               delay_ms(2); 
119C:  MOVLW  02
119E:  MOVWF  08
11A0:  RCALL  103E
....................             break; 
11A2:  BRA    11C4
....................      case '\n'   : 
....................      case '\r'    :   lcd_pos_xy(1,2); 
11A4:  MOVLW  01
11A6:  MOVWF  08
11A8:  MOVLW  02
11AA:  MOVWF  09
11AC:  BRA    115C
....................               break; 
11AE:  BRA    11C4
....................      case '\b'    :   lcd_envia_byte(0,0x10); 
11B0:  CLRF   0C
11B2:  MOVLW  10
11B4:  MOVWF  0D
11B6:  RCALL  10C2
....................               break; 
11B8:  BRA    11C4
....................      default   :   lcd_envia_byte(1,c); 
11BA:  MOVLW  01
11BC:  MOVWF  0C
11BE:  MOVFF  07,0D
11C2:  RCALL  10C2
....................               break; 
....................    } 
11C4:  GOTO   11DC (RETURN)
.................... } 
....................  
.................... char lcd_le( byte x, byte y) 
.................... // le caractere do display 
.................... { 
....................    char valor; 
....................    // seleciona a posição do caractere 
....................    lcd_pos_xy(x,y); 
....................    // ativa rs 
....................    output_high(lcd_rs); 
....................    // lê o caractere 
....................    valor = lcd_le_byte(); 
....................    // desativa rs 
....................    output_low(lcd_rs); 
....................    // retorna o valor do caractere 
....................    return valor; 
.................... } 
....................  
.................... void lcd_apaga() 
.................... { 
....................    lcd_envia_byte(0,1); 
....................    delay_ms(2); 
.................... } 
....................  
.................... void lcd_cursor_on() 
....................     { 
.................... lcd_envia_byte(0,0x0E); 
....................     } 
....................  
.................... void lcd_cursor_pisca() 
....................     { 
.................... lcd_envia_byte(0,0x0F); 
....................     } 
....................  
.................... void lcd_cursor_off() 
....................     { 
....................  lcd_envia_byte(0,0x0C); 
....................     } 
....................  
.................... void lcd_corre_esquerda() 
....................     { 
....................  lcd_envia_byte(0,0x18); 
....................     } 
....................  
.................... void lcd_corre_direita() 
....................     { 
.................... lcd_envia_byte(0,0x1C); 
....................     } 
....................  
....................  
....................  
.................... // #include<SonarV1.1.c> 
.................... // #include<LinhasV1.1.c> 
....................  
.................... // #define  ch1    pin_a4 
.................... // #define  ch2   pin_a5 
.................... // #define  ch3   pin_e0 
.................... // #define  ch4   pin_e1 
....................  
.................... // void sonar_modos(){ 
.................... //    do{ 
.................... //    printf(lcd_escreve,"\f1. Livre\n2. Labirinto"); 
.................... //    delay_ms(100); 
.................... //       if(input(ch1)==0){ 
.................... //       } 
.................... //       if(input(ch2)==0){ 
.................... //          while(input(ch2)==0); 
.................... //          do{ 
.................... //          sonar_labirinto();}while(input(ch3)==1); 
.................... //       } 
.................... //       if(input(ch3)==0){ 
.................... //          do{ 
.................... //          printf(lcd_escreve,"\f3. Display"); 
.................... //          delay_ms(100); 
.................... //          if(input(ch1)==0){ 
.................... //             while(input(ch1)==0); 
.................... //             do{ 
.................... //                sonar_display();}while(input(ch3)==1); 
.................... //             } 
.................... //          }while(input(ch4)==1); 
.................... //       } 
.................... //    }while(input(ch4)==1); 
.................... // } 
....................  
.................... void main() 
*
11E8:  CLRF   FF8
11EA:  BCF    FD0.7
11EC:  MOVF   FC1,W
11EE:  ANDLW  C0
11F0:  IORLW  0F
11F2:  MOVWF  FC1
11F4:  MOVLW  07
11F6:  MOVWF  FB4
.................... { 
....................    lcd_ini(); 
11F8:  BRA    10F6
....................    //motor_ini(); 
....................    //set_pwm(1000);  
....................  
....................    //float distancia1=0,distancia2=0,distancia3=0; 
....................    printf(lcd_escreve,"\fImposto V1.2"); 
11FA:  MOVLW  1C
11FC:  MOVWF  FF6
11FE:  MOVLW  10
1200:  MOVWF  FF7
1202:  RCALL  11C8
....................    delay_ms(2000); 
1204:  MOVLW  08
1206:  MOVWF  05
1208:  MOVLW  FA
120A:  MOVWF  08
120C:  RCALL  103E
120E:  DECFSZ 05,F
1210:  BRA    1208
....................    do{ 
....................       printf(lcd_escreve,"\f1. Linhas\n2. Sonar"); 
1212:  MOVLW  2A
1214:  MOVWF  FF6
1216:  MOVLW  10
1218:  MOVWF  FF7
121A:  RCALL  11C8
....................       delay_ms(20); 
121C:  MOVLW  14
121E:  MOVWF  08
1220:  RCALL  103E
....................     //   if(input(ch1)==0){ 
....................     //      while(input(ch1)==0); 
....................     //      linhas(); 
....................     //   } 
....................     //   if(input(ch2)==0){ 
....................     //      while(input(ch2)==0); 
....................     //      sonar_modos(); 
....................     //   } 
....................    }while(1); 
1222:  BRA    1212
....................     
....................    /* 
....................    do{ 
....................       sonar_display(); 
....................    }while(input(ch1)==1); 
....................     
....................    while(input(ch1)==0); 
....................  
....................    do{ 
....................       sonar_labirinto(); 
....................    }while(1); 
.................... */ 
.................... } 
....................  
1224:  SLEEP 
....................  
....................  
....................  
....................  
....................  
....................  

Configuration Fuses:
   Word  1: CE24   PLL5 CPUDIV1 USBDIV HSPLL FCMEN IESO
   Word  2: 0E38   PUT NOBROWNOUT BORV21 VREGEN NOWDT WDT128
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
